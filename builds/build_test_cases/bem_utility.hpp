
// できるだけカプセル化することが，今後の変更を最小に抑えてくれる．
// この観点から幾何学関連の操作（面の抽出や三角分割など）は，bemには持ち込まない．
#ifndef INCL_BEM
#define INCL_BEM
namespace BEM
{
  // to generate __GWGWn__
  //------------------------------------------------  
  // for(auto i=2; i<11;i++){
  //   VV_d gw = GaussianQuadratureWeights(5,0.,1.);
  //   VV_d gwgw;
  //   for(const auto& tw0:gw){
  //     double xi = tw0[0];
  //     double w_xi = tw0[1];
  //     for(const auto& tw1:gw){
  //       double h = tw1[0];
  //       double w_h = tw1[1];
  //       gwgw.push_back({xi, h*(1.-xi) , w_xi * w_h*(1.-xi), w_xi * w_h/*1-xiなし*/});
  //     }
  //   }
  //   std::cout << "const static std::vector<std::vector<double>> __GWGW" << std::setprecision(15) << std::to_string(i) << "__ = " << gwgw << ";"<< std::endl;
  // }
  //------------------------------------------------  
  const static std::vector<std::vector<double>> __GWGW2__ = {{0.046910077030668,0.0447095217036448,0.0133752705583056,0.0140335872156063},{0.046910077030668,0.219940124839679,0.0270200993161797,0.0283499999999991},{0.046910077030668,0.476544961484666,0.0321155735648085,0.0336962680968792},{0.046910077030668,0.733149798129653,0.0270200993161797,0.0283499999999991},{0.046910077030668,0.908380401265687,0.0133752705583056,0.0140335872156063},{0.230765344947158,0.0360848569231881,0.0218078024707474,0.0283499999999991},{0.230765344947158,0.177512700518577,0.0440551079739706,0.0572713510559978},{0.230765344947158,0.384617327526421,0.0523630592355528,0.0680716331376877},{0.230765344947158,0.591721954534264,0.0440551079739706,0.0572713510559978},{0.230765344947158,0.733149798129653,0.0218078024707474,0.0283499999999991},{0.5,0.023455038515334,0.0168481340484396,0.0336962680968792},{0.5,0.115382672473579,0.0340358165688438,0.0680716331376877},{0.5,0.25,0.0404543209876543,0.0809086419753086},{0.5,0.384617327526421,0.0340358165688438,0.0680716331376877},{0.5,0.476544961484666,0.0168481340484396,0.0336962680968792},{0.769234655052841,0.0108252201074799,0.00654219752925174,0.0283499999999991},{0.769234655052841,0.053252644428581,0.0132162430820271,0.0572713510559978},{0.769234655052841,0.115382672473579,0.0157085739021349,0.0680716331376877},{0.769234655052841,0.177512700518577,0.0132162430820271,0.0572713510559978},{0.769234655052841,0.219940124839679,0.00654219752925174,0.0283499999999991},{0.953089922969332,0.00220055532702321,0.00065831665730069,0.0140335872156063},{0.953089922969332,0.0108252201074799,0.0013299006838194,0.0283499999999991},{0.953089922969332,0.023455038515334,0.00158069453207065,0.0336962680968792},{0.953089922969332,0.0360848569231882,0.0013299006838194,0.0283499999999991},{0.953089922969332,0.0447095217036449,0.00065831665730069,0.0140335872156063}};
  const static std::vector<std::vector<double>> __GWGW3__ = {{0.046910077030668,0.0447095217036448,0.0133752705583056,0.0140335872156063},{0.046910077030668,0.219940124839679,0.0270200993161797,0.0283499999999991},{0.046910077030668,0.476544961484666,0.0321155735648085,0.0336962680968792},{0.046910077030668,0.733149798129653,0.0270200993161797,0.0283499999999991},{0.046910077030668,0.908380401265687,0.0133752705583056,0.0140335872156063},{0.230765344947158,0.0360848569231881,0.0218078024707474,0.0283499999999991},{0.230765344947158,0.177512700518577,0.0440551079739706,0.0572713510559978},{0.230765344947158,0.384617327526421,0.0523630592355528,0.0680716331376877},{0.230765344947158,0.591721954534264,0.0440551079739706,0.0572713510559978},{0.230765344947158,0.733149798129653,0.0218078024707474,0.0283499999999991},{0.5,0.023455038515334,0.0168481340484396,0.0336962680968792},{0.5,0.115382672473579,0.0340358165688438,0.0680716331376877},{0.5,0.25,0.0404543209876543,0.0809086419753086},{0.5,0.384617327526421,0.0340358165688438,0.0680716331376877},{0.5,0.476544961484666,0.0168481340484396,0.0336962680968792},{0.769234655052841,0.0108252201074799,0.00654219752925174,0.0283499999999991},{0.769234655052841,0.053252644428581,0.0132162430820271,0.0572713510559978},{0.769234655052841,0.115382672473579,0.0157085739021349,0.0680716331376877},{0.769234655052841,0.177512700518577,0.0132162430820271,0.0572713510559978},{0.769234655052841,0.219940124839679,0.00654219752925174,0.0283499999999991},{0.953089922969332,0.00220055532702321,0.00065831665730069,0.0140335872156063},{0.953089922969332,0.0108252201074799,0.0013299006838194,0.0283499999999991},{0.953089922969332,0.023455038515334,0.00158069453207065,0.0336962680968792},{0.953089922969332,0.0360848569231882,0.0013299006838194,0.0283499999999991},{0.953089922969332,0.0447095217036449,0.00065831665730069,0.0140335872156063}};
  const static std::vector<std::vector<double>> __GWGW4__ = {{0.046910077030668,0.0447095217036448,0.0133752705583056,0.0140335872156063},{0.046910077030668,0.219940124839679,0.0270200993161797,0.0283499999999991},{0.046910077030668,0.476544961484666,0.0321155735648085,0.0336962680968792},{0.046910077030668,0.733149798129653,0.0270200993161797,0.0283499999999991},{0.046910077030668,0.908380401265687,0.0133752705583056,0.0140335872156063},{0.230765344947158,0.0360848569231881,0.0218078024707474,0.0283499999999991},{0.230765344947158,0.177512700518577,0.0440551079739706,0.0572713510559978},{0.230765344947158,0.384617327526421,0.0523630592355528,0.0680716331376877},{0.230765344947158,0.591721954534264,0.0440551079739706,0.0572713510559978},{0.230765344947158,0.733149798129653,0.0218078024707474,0.0283499999999991},{0.5,0.023455038515334,0.0168481340484396,0.0336962680968792},{0.5,0.115382672473579,0.0340358165688438,0.0680716331376877},{0.5,0.25,0.0404543209876543,0.0809086419753086},{0.5,0.384617327526421,0.0340358165688438,0.0680716331376877},{0.5,0.476544961484666,0.0168481340484396,0.0336962680968792},{0.769234655052841,0.0108252201074799,0.00654219752925174,0.0283499999999991},{0.769234655052841,0.053252644428581,0.0132162430820271,0.0572713510559978},{0.769234655052841,0.115382672473579,0.0157085739021349,0.0680716331376877},{0.769234655052841,0.177512700518577,0.0132162430820271,0.0572713510559978},{0.769234655052841,0.219940124839679,0.00654219752925174,0.0283499999999991},{0.953089922969332,0.00220055532702321,0.00065831665730069,0.0140335872156063},{0.953089922969332,0.0108252201074799,0.0013299006838194,0.0283499999999991},{0.953089922969332,0.023455038515334,0.00158069453207065,0.0336962680968792},{0.953089922969332,0.0360848569231882,0.0013299006838194,0.0283499999999991},{0.953089922969332,0.0447095217036449,0.00065831665730069,0.0140335872156063}};
  const static std::vector<std::vector<double>> __GWGW5__ = {{0.046910077030668,0.0447095217036448,0.0133752705583056,0.0140335872156063},{0.046910077030668,0.219940124839679,0.0270200993161797,0.0283499999999991},{0.046910077030668,0.476544961484666,0.0321155735648085,0.0336962680968792},{0.046910077030668,0.733149798129653,0.0270200993161797,0.0283499999999991},{0.046910077030668,0.908380401265687,0.0133752705583056,0.0140335872156063},{0.230765344947158,0.0360848569231881,0.0218078024707474,0.0283499999999991},{0.230765344947158,0.177512700518577,0.0440551079739706,0.0572713510559978},{0.230765344947158,0.384617327526421,0.0523630592355528,0.0680716331376877},{0.230765344947158,0.591721954534264,0.0440551079739706,0.0572713510559978},{0.230765344947158,0.733149798129653,0.0218078024707474,0.0283499999999991},{0.5,0.023455038515334,0.0168481340484396,0.0336962680968792},{0.5,0.115382672473579,0.0340358165688438,0.0680716331376877},{0.5,0.25,0.0404543209876543,0.0809086419753086},{0.5,0.384617327526421,0.0340358165688438,0.0680716331376877},{0.5,0.476544961484666,0.0168481340484396,0.0336962680968792},{0.769234655052841,0.0108252201074799,0.00654219752925174,0.0283499999999991},{0.769234655052841,0.053252644428581,0.0132162430820271,0.0572713510559978},{0.769234655052841,0.115382672473579,0.0157085739021349,0.0680716331376877},{0.769234655052841,0.177512700518577,0.0132162430820271,0.0572713510559978},{0.769234655052841,0.219940124839679,0.00654219752925174,0.0283499999999991},{0.953089922969332,0.00220055532702321,0.00065831665730069,0.0140335872156063},{0.953089922969332,0.0108252201074799,0.0013299006838194,0.0283499999999991},{0.953089922969332,0.023455038515334,0.00158069453207065,0.0336962680968792},{0.953089922969332,0.0360848569231882,0.0013299006838194,0.0283499999999991},{0.953089922969332,0.0447095217036449,0.00065831665730069,0.0140335872156063}};
  const static std::vector<std::vector<double>> __GWGW6__ = {{0.046910077030668,0.0447095217036448,0.0133752705583056,0.0140335872156063},{0.046910077030668,0.219940124839679,0.0270200993161797,0.0283499999999991},{0.046910077030668,0.476544961484666,0.0321155735648085,0.0336962680968792},{0.046910077030668,0.733149798129653,0.0270200993161797,0.0283499999999991},{0.046910077030668,0.908380401265687,0.0133752705583056,0.0140335872156063},{0.230765344947158,0.0360848569231881,0.0218078024707474,0.0283499999999991},{0.230765344947158,0.177512700518577,0.0440551079739706,0.0572713510559978},{0.230765344947158,0.384617327526421,0.0523630592355528,0.0680716331376877},{0.230765344947158,0.591721954534264,0.0440551079739706,0.0572713510559978},{0.230765344947158,0.733149798129653,0.0218078024707474,0.0283499999999991},{0.5,0.023455038515334,0.0168481340484396,0.0336962680968792},{0.5,0.115382672473579,0.0340358165688438,0.0680716331376877},{0.5,0.25,0.0404543209876543,0.0809086419753086},{0.5,0.384617327526421,0.0340358165688438,0.0680716331376877},{0.5,0.476544961484666,0.0168481340484396,0.0336962680968792},{0.769234655052841,0.0108252201074799,0.00654219752925174,0.0283499999999991},{0.769234655052841,0.053252644428581,0.0132162430820271,0.0572713510559978},{0.769234655052841,0.115382672473579,0.0157085739021349,0.0680716331376877},{0.769234655052841,0.177512700518577,0.0132162430820271,0.0572713510559978},{0.769234655052841,0.219940124839679,0.00654219752925174,0.0283499999999991},{0.953089922969332,0.00220055532702321,0.00065831665730069,0.0140335872156063},{0.953089922969332,0.0108252201074799,0.0013299006838194,0.0283499999999991},{0.953089922969332,0.023455038515334,0.00158069453207065,0.0336962680968792},{0.953089922969332,0.0360848569231882,0.0013299006838194,0.0283499999999991},{0.953089922969332,0.0447095217036449,0.00065831665730069,0.0140335872156063}};
  const static std::vector<std::vector<double>> __GWGW7__ = {{0.046910077030668,0.0447095217036448,0.0133752705583056,0.0140335872156063},{0.046910077030668,0.219940124839679,0.0270200993161797,0.0283499999999991},{0.046910077030668,0.476544961484666,0.0321155735648085,0.0336962680968792},{0.046910077030668,0.733149798129653,0.0270200993161797,0.0283499999999991},{0.046910077030668,0.908380401265687,0.0133752705583056,0.0140335872156063},{0.230765344947158,0.0360848569231881,0.0218078024707474,0.0283499999999991},{0.230765344947158,0.177512700518577,0.0440551079739706,0.0572713510559978},{0.230765344947158,0.384617327526421,0.0523630592355528,0.0680716331376877},{0.230765344947158,0.591721954534264,0.0440551079739706,0.0572713510559978},{0.230765344947158,0.733149798129653,0.0218078024707474,0.0283499999999991},{0.5,0.023455038515334,0.0168481340484396,0.0336962680968792},{0.5,0.115382672473579,0.0340358165688438,0.0680716331376877},{0.5,0.25,0.0404543209876543,0.0809086419753086},{0.5,0.384617327526421,0.0340358165688438,0.0680716331376877},{0.5,0.476544961484666,0.0168481340484396,0.0336962680968792},{0.769234655052841,0.0108252201074799,0.00654219752925174,0.0283499999999991},{0.769234655052841,0.053252644428581,0.0132162430820271,0.0572713510559978},{0.769234655052841,0.115382672473579,0.0157085739021349,0.0680716331376877},{0.769234655052841,0.177512700518577,0.0132162430820271,0.0572713510559978},{0.769234655052841,0.219940124839679,0.00654219752925174,0.0283499999999991},{0.953089922969332,0.00220055532702321,0.00065831665730069,0.0140335872156063},{0.953089922969332,0.0108252201074799,0.0013299006838194,0.0283499999999991},{0.953089922969332,0.023455038515334,0.00158069453207065,0.0336962680968792},{0.953089922969332,0.0360848569231882,0.0013299006838194,0.0283499999999991},{0.953089922969332,0.0447095217036449,0.00065831665730069,0.0140335872156063}};
  const static std::vector<std::vector<double>> __GWGW8__ = {{0.046910077030668,0.0447095217036448,0.0133752705583056,0.0140335872156063},{0.046910077030668,0.219940124839679,0.0270200993161797,0.0283499999999991},{0.046910077030668,0.476544961484666,0.0321155735648085,0.0336962680968792},{0.046910077030668,0.733149798129653,0.0270200993161797,0.0283499999999991},{0.046910077030668,0.908380401265687,0.0133752705583056,0.0140335872156063},{0.230765344947158,0.0360848569231881,0.0218078024707474,0.0283499999999991},{0.230765344947158,0.177512700518577,0.0440551079739706,0.0572713510559978},{0.230765344947158,0.384617327526421,0.0523630592355528,0.0680716331376877},{0.230765344947158,0.591721954534264,0.0440551079739706,0.0572713510559978},{0.230765344947158,0.733149798129653,0.0218078024707474,0.0283499999999991},{0.5,0.023455038515334,0.0168481340484396,0.0336962680968792},{0.5,0.115382672473579,0.0340358165688438,0.0680716331376877},{0.5,0.25,0.0404543209876543,0.0809086419753086},{0.5,0.384617327526421,0.0340358165688438,0.0680716331376877},{0.5,0.476544961484666,0.0168481340484396,0.0336962680968792},{0.769234655052841,0.0108252201074799,0.00654219752925174,0.0283499999999991},{0.769234655052841,0.053252644428581,0.0132162430820271,0.0572713510559978},{0.769234655052841,0.115382672473579,0.0157085739021349,0.0680716331376877},{0.769234655052841,0.177512700518577,0.0132162430820271,0.0572713510559978},{0.769234655052841,0.219940124839679,0.00654219752925174,0.0283499999999991},{0.953089922969332,0.00220055532702321,0.00065831665730069,0.0140335872156063},{0.953089922969332,0.0108252201074799,0.0013299006838194,0.0283499999999991},{0.953089922969332,0.023455038515334,0.00158069453207065,0.0336962680968792},{0.953089922969332,0.0360848569231882,0.0013299006838194,0.0283499999999991},{0.953089922969332,0.0447095217036449,0.00065831665730069,0.0140335872156063}};
  const static std::vector<std::vector<double>> __GWGW9__ = {{0.046910077030668,0.0447095217036448,0.0133752705583056,0.0140335872156063},{0.046910077030668,0.219940124839679,0.0270200993161797,0.0283499999999991},{0.046910077030668,0.476544961484666,0.0321155735648085,0.0336962680968792},{0.046910077030668,0.733149798129653,0.0270200993161797,0.0283499999999991},{0.046910077030668,0.908380401265687,0.0133752705583056,0.0140335872156063},{0.230765344947158,0.0360848569231881,0.0218078024707474,0.0283499999999991},{0.230765344947158,0.177512700518577,0.0440551079739706,0.0572713510559978},{0.230765344947158,0.384617327526421,0.0523630592355528,0.0680716331376877},{0.230765344947158,0.591721954534264,0.0440551079739706,0.0572713510559978},{0.230765344947158,0.733149798129653,0.0218078024707474,0.0283499999999991},{0.5,0.023455038515334,0.0168481340484396,0.0336962680968792},{0.5,0.115382672473579,0.0340358165688438,0.0680716331376877},{0.5,0.25,0.0404543209876543,0.0809086419753086},{0.5,0.384617327526421,0.0340358165688438,0.0680716331376877},{0.5,0.476544961484666,0.0168481340484396,0.0336962680968792},{0.769234655052841,0.0108252201074799,0.00654219752925174,0.0283499999999991},{0.769234655052841,0.053252644428581,0.0132162430820271,0.0572713510559978},{0.769234655052841,0.115382672473579,0.0157085739021349,0.0680716331376877},{0.769234655052841,0.177512700518577,0.0132162430820271,0.0572713510559978},{0.769234655052841,0.219940124839679,0.00654219752925174,0.0283499999999991},{0.953089922969332,0.00220055532702321,0.00065831665730069,0.0140335872156063},{0.953089922969332,0.0108252201074799,0.0013299006838194,0.0283499999999991},{0.953089922969332,0.023455038515334,0.00158069453207065,0.0336962680968792},{0.953089922969332,0.0360848569231882,0.0013299006838194,0.0283499999999991},{0.953089922969332,0.0447095217036449,0.00065831665730069,0.0140335872156063}};
  const static std::vector<std::vector<double>> __GWGW10__ = {{0.046910077030668,0.0447095217036448,0.0133752705583056,0.0140335872156063},{0.046910077030668,0.219940124839679,0.0270200993161797,0.0283499999999991},{0.046910077030668,0.476544961484666,0.0321155735648085,0.0336962680968792},{0.046910077030668,0.733149798129653,0.0270200993161797,0.0283499999999991},{0.046910077030668,0.908380401265687,0.0133752705583056,0.0140335872156063},{0.230765344947158,0.0360848569231881,0.0218078024707474,0.0283499999999991},{0.230765344947158,0.177512700518577,0.0440551079739706,0.0572713510559978},{0.230765344947158,0.384617327526421,0.0523630592355528,0.0680716331376877},{0.230765344947158,0.591721954534264,0.0440551079739706,0.0572713510559978},{0.230765344947158,0.733149798129653,0.0218078024707474,0.0283499999999991},{0.5,0.023455038515334,0.0168481340484396,0.0336962680968792},{0.5,0.115382672473579,0.0340358165688438,0.0680716331376877},{0.5,0.25,0.0404543209876543,0.0809086419753086},{0.5,0.384617327526421,0.0340358165688438,0.0680716331376877},{0.5,0.476544961484666,0.0168481340484396,0.0336962680968792},{0.769234655052841,0.0108252201074799,0.00654219752925174,0.0283499999999991},{0.769234655052841,0.053252644428581,0.0132162430820271,0.0572713510559978},{0.769234655052841,0.115382672473579,0.0157085739021349,0.0680716331376877},{0.769234655052841,0.177512700518577,0.0132162430820271,0.0572713510559978},{0.769234655052841,0.219940124839679,0.00654219752925174,0.0283499999999991},{0.953089922969332,0.00220055532702321,0.00065831665730069,0.0140335872156063},{0.953089922969332,0.0108252201074799,0.0013299006838194,0.0283499999999991},{0.953089922969332,0.023455038515334,0.00158069453207065,0.0336962680968792},{0.953089922969332,0.0360848569231882,0.0013299006838194,0.0283499999999991},{0.953089922969332,0.0447095217036449,0.00065831665730069,0.0140335872156063}};

  using V_d = std::vector<double>;
  using V_i = std::vector<int>;
  using VV_d = std::vector<V_d>;
  using VVV_d = std::vector<VV_d>;

  using netFp = networkFace*;
  
  using netP = networkPoint;
  using netPp = networkPoint*;    
  using V_netPp = std::vector<networkPoint*>;  
  using VV_netPp = std::vector<V_netPp>;

  using netF = networkFace;
  using V_netFp = std::vector<netF*>;  
  /// USE LIKE Dot( N(ab), sample )
  
  V_d N(const V_d& ab){return {ab[0], ab[1], 1.-(ab[0]+ab[1])};};

  V_d dNd_(const int& i){
    switch(i){
    case 0:
      return {1., 0., -1.};
    case 1:
      return {0., 1., -1.};
    default:
      Print(__PRETTY_FUNCTION__);
      abort();
      return {0.,0.,0.};
    }
  };

  VV_d dNd_(){return {{1., 0., -1.},{0., 1., -1.}};};
  
  using map_P_Vd = std::map<netPp, V_d>;
  using map_P_d = std::map<netPp, double>;

  V_d parameterize(const V_netPp& points, const netPp& p){
    for(auto i=0; i<points.size(); i++){
      if(p==points[i]){
	switch(i){
        case 0:
	  return {1.,0.,0.};
        case 1:
	  return {0.,1.,0.};
        case 2:
	  return {0.,0.,1.};
        default:
          Print(__PRETTY_FUNCTION__);
          abort();          
	}
      }
    }
    Print(__PRETTY_FUNCTION__);
    abort();    
  };

  /// global to local: {s,m,n}
  VV_d M(const netFp& f, const V_d& ab){
    VV_d xyzs = f->getLocations();
    auto dXds0 = Dot(dNd_(0), xyzs);
    auto dXds1 = Dot(dNd_(1), xyzs);
    return {dXds0/Norm(dXds0)/*s*/,
	    dXds1/Norm(dXds1)/*m*/,
	    f->getNormal()/Norm(f->getNormal())/*n*/};
  };

  // VV_d M(const VV_d& xyzs, const V_d& ab){
  //   auto dXds0 = Dot(dNd_(0), xyzs);
  //   auto dXds1 = Dot(dNd_(1), xyzs);
  //   auto cross = Cross(dXds0,dXds1);
  //   return {dXds0/Norm(dXds0)/*s*/,
  //           dXds1/Norm(dXds1)/*m*/,
  //           cross/Norm(cross)/*n*/};
  // };


  // V_d vG(const VV_d& X, const V_d& Phi){
  //   double toosmall = 1E-9;
  //   double d10 = Norm(X[1] - X[0]);
  //   double d20 = Norm(X[2] - X[0]);
  //   double d21 = Norm(X[2] - X[1]);
    
  //   if( d10 < toosmall && d20 < toosmall ){
      
  //     v_L = {Dot(BEM::dNd_(0),Phi), Dot(BEM::dNd_(1),Phi), phiphin[1]};
  //   }else if( d10 < toosmall){

  //   }else if( d20 < toosmall){

  //   }else{

  //   }
    
  //   return ret;
  // };


  パラメタがあっていない
  V_d vG(V_d param, const VV_d& X, const V_d& Phi, const double phin){
    return Dot( Inverse(BEM::M(f,param)),
                { Dot(BEM::dNd_(0),Phi), Dot(BEM::dNd_(1),Phi), phin }/*local velocity*/);// global velocity
  };
  
  /// THIS ONLY USES ACTIVATED FACES
  map_P_d DphiDt(map_P_Vd& P_phiphin, const V_netFp& Faces, const double water_level, const bool TorF=true){
    Print("BEM::DphiDt(P_phiphin)　今はここで定義",red);
    map_P_d ret;
    
    V_d Phi(3), v_L, v_G;
    VV_d M_;
    V_d param;
    V_netPp ps;
    for(const auto& [p, phiphin]:P_phiphin){
      VV_d vv_G(0);
      bool calculated=false;
                          
      for(const auto& f:p->getFaces()){
        if(MemberQ(Faces,f)){

          ps = f->getPoints();

          if(ps.size()<3)
            throw(error_message(__FILE__,__PRETTY_FUNCTION__,__LINE__,"ps.size()<3"));

          auto X = obj3D::extractX(ps);


          Phi = {P_phiphin[ps[0]][0],
                 P_phiphin[ps[1]][0],
                 P_phiphin[ps[2]][0]};

          v_L = { Dot(BEM::dNd_(0),Phi), Dot(BEM::dNd_(1),Phi), phiphin[1] };

          param = BEM::parameterize(ps, p);
          M_ = Inverse(BEM::M(f,param));
          v_G = Dot( M_ , v_L/*local velocity*/);// global velocity                            
          vv_G.emplace_back(v_G);

          calculated = true;
          
        }
      }

      if(!calculated){
        mk_vtu_("./vtu/p.vtu", {{p}});
        throw(error_message(__FILE__,__PRETTY_FUNCTION__,__LINE__,"no face is found"));
      }

      ret[p] = pow(Norm(Mean(vv_G)),2)/2. - (p->getX()[2]-water_level);
                          
    }
    return ret;
  };
  
  /// THIS ONLY USES ACTIVATED FACES
  ///   *---*
  ///  / \ / \
  /// *---@---*
  ///  \ / \ /
  ///   *---*
  map_P_Vd nablaPhi(map_P_Vd& P_phiphin, const V_netFp& Faces, std::vector<Network*> nets={}){
    map_P_Vd ret;
    V_d Phi(3), u, ab, v_L, v_G;

    for(auto& [p, phiphin]:P_phiphin){
      //      if(!MemberQ(nets,p->getNetwork())){
      VV_d nablaPhi;
      bool found = false;      
      for(const auto& f:p->getFaces())
        if(MemberQ(Faces,f)){
          // tmpF.push_back(f);
          auto ps = f->getPoints();
          
          if(ps.size()<3)
            throw(error_message(__FILE__,__PRETTY_FUNCTION__,__LINE__,"ps.size()<3"));
          
          Phi[0] = P_phiphin[ps[0]][0];
          Phi[1] = P_phiphin[ps[1]][0];
          Phi[2] = P_phiphin[ps[2]][0];

          v_L = { Dot(dNd_(0),Phi), Dot(dNd_(1),Phi), phiphin[1] };
          nablaPhi.emplace_back(Dot(Inverse(M(f,parameterize(ps,p))), v_L));
          found = true;
        }

      if(!found){
        mk_vtu_("./vtu/p.vtu", {{p}});
        throw(error_message(__FILE__,__PRETTY_FUNCTION__,__LINE__,"no face is found"));
      }

      ret[p] = Mean(nablaPhi);
      
    }
    
    return ret;
  };


  
  std::map<netP*, V_d> sum(const std::map<netF*, std::map<netP*, V_d>>& IGIGn){
    std::map<netP*, V_d> ret;

    for( auto const& [f, p_igign] : IGIGn){
      for( auto const& [p, igign] : p_igign){      
	ret[p] += igign;
      }
    }      
    return ret;
  };
  
  /*F_detail
    F_detail*/  
  V_d F(const VV_d& xyzs, const V_d& ab, const V_d& A){
    /// ローカルな面上の座標に沿って積分
    /// |detJ|の代わりに，z=0として，cross = Cross(Dot(dNd_(0), xyzs), Dot(dNd_(1), xyzs))のabs(cross[2])を使用，
    
    V_d r = Dot(N(ab),xyzs)-A;
    auto cross = Cross(xyzs[0]-xyzs[2]/*dXdxi*/, xyzs[1]-xyzs[2]/*dXdeta*/);    
    double nr = Norm(r);
    return {abs(cross[2])/nr, - Dot(r,cross)/(nr*nr*nr)};
    
    /// calculate IG and IGn that satisfy
    /// IG *  phi_n  = (IGn - c * delta)  * phi
    //---------------------------------------------

    //20201014    
    //S. T. Grilli, 2001.
    // V_d r = Dot(N(ab),xyzs)-A;
    // auto dXdxi = xyzs[0]-xyzs[2];
    // auto dXdh = xyzs[1]-xyzs[2];
    // V_d cross = Cross(dXdxi, dXdh);
    // double nr = Norm(r);
    // auto n = cross/Norm(cross);
    // double abs_detJ = abs(dXdxi[2]*(-(dXdh[1]*n[0]) + dXdh[0]*n[1]) + dXdxi[1]*(dXdh[2]*n[0] - dXdh[0]*n[2]) + dXdxi[0]*(-(dXdh[2]*n[1]) + dXdh[1]*n[2]));      
    // return {abs_detJ/nr, - Dot(r,cross)/(nr*nr*nr)};
    
  };

  V_d FF(const V_d& cross, const V_d& r){
    /// ローカルな面上の座標に沿って積分
    /// |detJ|の代わりに，z=0として，cross = Cross(Dot(dNd_(0), xyzs), Dot(dNd_(1), xyzs))のabs(cross[2])を使用，    
    double nr;
    return {abs(cross[2])/(nr = Norm(r)), - Dot(r,cross)/(nr*nr*nr)};    
    /// calculate IG and IGn that satisfy
    /// IG *  phi_n  = (IGn - c * delta)  * phi
    //-------------------------------------------    
  };  
  
  /*F_detail
    F_detail*/  
  V_d F_(const VV_d& xyzs, const V_d& ab, const V_d& A){
    /// ローカルな面上の座標に沿って積分
    /// |detJ|の代わりに，z=0として，cross = Cross(Dot(dNd_(0), xyzs), Dot(dNd_(1), xyzs))のabs(cross[2])を使用，
    
    // auto dXdxi = xyzs[0]-xyzs[2];
    // auto dXdeta = xyzs[1]-xyzs[2];
    // auto cross = Cross(dXdxi, dXdeta);    
    // // V_d r_ = -(xyzs[0] - xyzs[2]) + (xyzs[1] - xyzs[2])*ab[1];
    // V_d r_ = - dXdxi + dXdeta*ab[1];
    // double nr_ = Norm(r_);
    // return {abs(cross[2])/nr_, - Dot(r_, cross)/(nr_*nr_*nr_*(1.-ab[0]))};

    // /// calculate IG and IGn that satisfy
    // /// IG *  phi_n  = (IGn - c * delta)  * phi

    //20201024
    auto dXdxi = xyzs[0]-xyzs[2];
    auto dXdeta = xyzs[1]-xyzs[2];
    V_d r_ = - dXdxi + dXdeta*ab[1];
    return {abs(Cross(dXdxi, dXdeta)[2])/Norm(r_), 0.};
  };
  
  //  static constexpr VV_d gwgw = GaussianQuadratureWeights(5, 0., 1.);
  std::map<netP*, V_d> calc_P_IGIGn(const netFp& f, const netPp& origin){    
    V_d A = origin->getX();    
    V_netPp ps = f->getPoints();

    int singular=-1;    
    if(ps[0]==origin)
      singular = 0;
    else if(ps[1]==origin)
      singular = 1;
    else if(ps[2]==origin)
      singular = 2;

    if(singular==-1)
      {
        
        // VV_d xyzs = obj3D::extractX(ps);
        // auto cross = Cross(xyzs[0]-xyzs[2]/*dXdxi*/, xyzs[1]-xyzs[2]/*dXdeta*/);
        // for(const auto& abw:__GWGW3__){
        //   igign = FF(cross, Dot(shapeF = N(abw),xyzs)-A);
        //   tmp0 += igign * shapeF[0] * abw[2];
        //   tmp1 += igign * shapeF[1] * abw[2];
        //   tmp2 += igign * shapeF[2] * abw[2];
        // }
        // return {{ps[0],tmp0},{ps[1],tmp1},{ps[2],tmp2}};


        //20201024 簡単化
        
        // VV_d xyzs = obj3D::extractX(ps);
        // auto cross = Cross(xyzs[0]-xyzs[2]/*dXdxi*/, xyzs[1]-xyzs[2]/*dXdeta*/);

        // shapeF = N(__GWGW3__[0]);
        // igign = FF(cross, Dot(shapeF,xyzs)-A);
        // tmp0 += igign * shapeF[0] * __GWGW3__[0][2];
        // tmp1 += igign * shapeF[1] * __GWGW3__[0][2];
        // tmp2 += igign * shapeF[2] * __GWGW3__[0][2];

        // shapeF = N(__GWGW3__[1]);
        // igign = FF(cross, Dot(shapeF,xyzs)-A);
        // tmp0 += igign * shapeF[0] * __GWGW3__[1][2];
        // tmp1 += igign * shapeF[1] * __GWGW3__[1][2];
        // tmp2 += igign * shapeF[2] * __GWGW3__[1][2];

        // shapeF = N(__GWGW3__[2]);
        // igign = FF(cross, Dot(shapeF,xyzs)-A);
        // tmp0 += igign * shapeF[0] * __GWGW3__[2][2];
        // tmp1 += igign * shapeF[1] * __GWGW3__[2][2];
        // tmp2 += igign * shapeF[2] * __GWGW3__[2][2];
        
        // return {{ps[0],tmp0},{ps[1],tmp1},{ps[2],tmp2}};    
        



        //20201024 簡単化GWGW
        VV_d xyzs = obj3D::extractX(ps);
        auto cross = Cross(xyzs[0]-xyzs[2]/*dXdxi*/, xyzs[1]-xyzs[2]/*dXdeta*/);

        V_d shapeF = N(__GWGW2__[0]);
        V_d igign = FF(cross, Dot(shapeF,xyzs)-A) * __GWGW2__[0][2];
        V_d tmp0 = igign * shapeF[0];
        V_d tmp1 = igign * shapeF[1];
        V_d tmp2 = igign * shapeF[2];

        shapeF = N(__GWGW2__[1]);
        igign = FF(cross, Dot(shapeF,xyzs)-A) * __GWGW2__[1][2];
        tmp0 += igign * shapeF[0];
        tmp1 += igign * shapeF[1];
        tmp2 += igign * shapeF[2];
        
        return {{ps[0],tmp0},{ps[1],tmp1},{ps[2],tmp2}};     


        // 3
        // VV_d xyzs = obj3D::extractX(ps);
        // auto cross = Cross(xyzs[0]-xyzs[2]/*dXdxi*/, xyzs[1]-xyzs[2]/*dXdeta*/);

        // V_d shapeF = N(__GWGW3__[0]);
        // V_d igign = FF(cross, Dot(shapeF,xyzs)-A) * __GWGW3__[0][2];
        // V_d tmp0 = igign * shapeF[0];
        // V_d tmp1 = igign * shapeF[1];
        // V_d tmp2 = igign * shapeF[2];

        // shapeF = N(__GWGW3__[1]);
        // igign = FF(cross, Dot(shapeF,xyzs)-A) * __GWGW3__[1][2];
        // tmp0 += igign * shapeF[0];
        // tmp1 += igign * shapeF[1];
        // tmp2 += igign * shapeF[2];

        // shapeF = N(__GWGW3__[2]);
        // igign = FF(cross, Dot(shapeF,xyzs)-A) * __GWGW3__[2][2];
        // tmp0 += igign * shapeF[0];
        // tmp1 += igign * shapeF[1];
        // tmp2 += igign * shapeF[2];
        
        // return {{ps[0],tmp0},{ps[1],tmp1},{ps[2],tmp2}};      

        
      }
    else
      {
        V_d igign={0,0};
        V_d shapeF;
        V_d tmp0={0,0}, tmp1={0,0}, tmp2={0,0};        
        std::rotate(ps.begin(),ps.begin()+singular,ps.end());
        VV_d xyz = obj3D::extractX(ps);        
        for(const auto& abw:__GWGW3__){
          igign = F_(xyz, abw, A) * abw[3];
          shapeF = N(abw);
          tmp0 += igign * shapeF[0];
          tmp1 += igign * shapeF[1];
          tmp2 += igign * shapeF[2];
        }
        return {{ps[0],tmp0},{ps[1],tmp1},{ps[2],tmp2}};
        
      }
  };
  //--------------------------------------------------
  
  std::map<netP*, V_d> calc_P_IGIGn_(const netFp& f, const netPp& origin, const VV_d& gwgw){    
    V_d igign={0,0}, cross={0,0,0}, A = origin->getX(), shapeF;
    V_netPp ps = f->getPoints();
    VV_d xyz = obj3D::extractX(ps);      
    V_d tmp0={0,0}, tmp1={0,0}, tmp2={0,0};
    for(const auto& abw:gwgw){
      igign = F(xyz, abw, A) * abw[2];
      shapeF = N(abw);
      tmp0 += igign * shapeF[0];
      tmp1 += igign * shapeF[1];
      tmp2 += igign * shapeF[2];
    }
    return {{ps[0],tmp0},{ps[1],tmp1},{ps[2],tmp2}};      
  };
  
  
  // std::map<netP*, V_d> calc_P_IGIGn_(const netFp& f, const netPp& origin, const VV_d& gwgw){    
  //   V_d igign={0,0}, cross={0,0,0}, A = origin->getX(), shapeF;
  //   V_netPp ps = f->getPoints();

    // int singular=-1;

    // for(auto i=0; i<3; i++){
    //   if(ps[i]==origin){
    //     singular = i;
    //   }
    // }
    
    // if(false && MemberQ(ps,origin)){
    //   int n = gwgw.size();
    //   V_d param = parameterize(ps, origin);
    //   VV_d gw0_ = GaussianQuadratureWeights(n, 0., 1., param[0], 2.);
    //   VV_d gw1_ = GaussianQuadratureWeights(n, 0., 1., param[1], 2.);
    //   // Print("singular GaussianQuadratureWeights",red);
    //   //std::cout << "parameterize : " << parameterize(ps, origin)<< std::endl;
    //   // std::cout << "gw0_ : " << gw0_ << std::endl;
    //   // std::cout << "gw1_ : " << gw1_ << std::endl;      
    //   V_d v;
    //   double a, b;
    //   VV_d gwgw_;
    //   for(const auto& tw0:gw0_){
    //     a = tw0[0];
    //     for(const auto& tw1:gw1_){
    //       v = tw1*(1-a);
    //       b = v[0];
    //       gwgw_.push_back({a, b , tw0[1] * v[1]});
    //     }
    //   }
    //   V_d tmp0={0,0}, tmp1={0,0}, tmp2={0,0};
    //   for(const auto& abw:gwgw_){
    //     igign = F(xyz, abw, A) * abw[2];
    //     shapeF = N(abw);
    //     tmp0 += igign * shapeF[0];
    //     tmp1 += igign * shapeF[1];
    //     tmp2 += igign * shapeF[2];
    //   }
    //   return {{ps[0],tmp0},{ps[1],tmp1},{ps[2],tmp2}};      
    // }

    // if(singular==-1){
    //   // for(auto i=0; i<3; i++)
    //   //   if(ps[i]!=origin){
    //   //     if(Norm(ps[i]->getX()-A)<1E-1)
    //   //       return ret;
    //   //   }
      
      // VV_d xyz = obj3D::extractX(ps);
      
      // V_d tmp0={0,0}, tmp1={0,0}, tmp2={0,0};
      // for(const auto& abw:gwgw){
      //   igign = F(xyz, abw, A) * abw[2];
      //   shapeF = N(abw);
      //   tmp0 += igign * shapeF[0];
      //   tmp1 += igign * shapeF[1];
      //   tmp2 += igign * shapeF[2];
      // }
      // return {{ps[0],tmp0},{ps[1],tmp1},{ps[2],tmp2}};      
      //}
      //else{

      //--------------------------------
      // int n = gwgw.size();
      // V_d param = parameterize(ps, origin);
      // VV_d gw0_ = GaussianQuadratureWeights(n, 0., 1., param[0], 2.);
      // VV_d gw1_ = GaussianQuadratureWeights(n, 0., 1., param[1], 2.);
      // V_d v;
      // double a, b;
      // VV_d gwgw_;
      // for(const auto& tw0:gw0_){
      //   a = tw0[0];
      //   for(const auto& tw1:gw1_){
      //     gwgw_.push_back({a, tw1[0]*(1.-a) , tw0[1] * tw1[1]});
      //   }
      // }
      //--------------------------------
      
    //   V_d tmp0={0,0}, tmp1={0,0}, tmp2={0,0};      
    //   std::rotate(ps.begin(),ps.begin()+singular,ps.end());
    //   VV_d xyz = obj3D::extractX(ps);
      
    //   for(const auto& abw:gwgw){
    //     igign = F_(xyz, abw, A) * abw[3];
    //     shapeF = N(abw);//なぜNrotateでいない？
    //     tmp0 += igign * shapeF[0];
    //     tmp1 += igign * shapeF[1];
    //     tmp2 += igign * shapeF[2];
    //   }
      
    //   return {{ps[0],tmp0},{ps[1],tmp1},{ps[2],tmp2}};
    // }
  // };

  // std::map<netP*, V_d> calc_P_IGIGn(const netFp& f, const netPp& origin, const VV_d& gwgw){
  //   V_d v, r, igign={0,0}, cross={0,0,0}, A = origin->getX();    
  //   V_netPp ps = f->getPoints();
  //   std::map<netP*, V_d> ret;
  //   V_d shapeF;
  //   ret[ps[0]] = {0,0};
  //   ret[ps[1]] = {0,0};
  //   ret[ps[2]] = {0,0};    
    
  //   VV_d xyzs_big = f->getLocations();

  //   if(f->intersectQ()){

  //     VV_d invTrX = Inverse(xyzs_big);
  //     VV_d xyzs_small, trT;
  //     V_d tmp0={0,0}, tmp1={0,0}, tmp2={0,0};
  //     for(const auto& routeP:f->getPointsCutFacesBehind()){
  //   	for(const auto& tri_ps:network::triangulate(routeP,f->getNormal())){
	  
  //   	  trT = Transpose(Dot( xyzs_small=obj3D::extractX(tri_ps), invTrX));
  // 	  tmp0={0,0};
  // 	  tmp1={0,0};
  // 	  tmp2={0,0};
  //   	  for(const auto& abw:gwgw){    
  // 	    igign = F(xyzs_small, abw, A) * abw[2];
  //   	    shapeF = Dot(trT, N(abw));
  //   	    tmp0 += igign * shapeF[0];
  //   	    tmp1 += igign * shapeF[1];
  //   	    tmp2 += igign * shapeF[2];
  //   	  }
  // 	  ret[ps[0]] += tmp0;
  // 	  ret[ps[1]] += tmp1;
  // 	  ret[ps[2]] += tmp2;	  
  //   	}
  //     }
      
  //   }
  //   else    
  //     {
  // 	V_d tmp0={0,0}, tmp1={0,0}, tmp2={0,0};
  // 	for(const auto& abw:gwgw){
  // 	  igign = F(xyzs_big, abw, A) * abw[2];
  // 	  shapeF = N(abw);
  // 	  tmp0 += igign * shapeF[0];
  // 	  tmp1 += igign * shapeF[1];
  // 	  tmp2 += igign * shapeF[2];
  // 	}
  // 	ret[ps[0]] = tmp0;
  // 	ret[ps[1]] = tmp1;
  // 	ret[ps[2]] = tmp2;		
  //     }
    
  //   return ret;
  // };
  
}
#endif
