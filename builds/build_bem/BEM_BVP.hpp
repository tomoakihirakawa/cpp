#ifndef BEM_BVP_H
#define BEM_BVP_H

#include "Network.hpp"
// #define use_CG
// #define use_gmres 20
#define use_lapack
std::unordered_map<std::tuple<netP *, bool, netF *>, int> PBF_index;

struct calculateFroudeKrylovForce {
   std::vector<networkFace *> actingFaces;
   Tddd force, torque;
   double area;
   T6d acceleration;
   std::vector<std::tuple<Tddd, T3Tddd>> PressureVeticies;
   calculateFroudeKrylovForce(const std::unordered_set<networkFace *> faces /*waterfaces*/,
                              const Network *PasObj)
       : force({0., 0., 0.}),
         torque({0., 0., 0.}),
         area(0.),
         PressureVeticies({}),
         acceleration({0., 0., 0., 0., 0., 0.}) {
      // PasObj„Å®Êé•„Åó„Åüface„ÅÆÈ†ÇÁÇπ„Å´pressure„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„ÇãÂâçÊèê
      int count = 0;
      for (const auto &f : faces)
         if (f->Neumann) {
            auto [p0, p1, p2] = f->getPoints();
            if (std::any_of(p0->getContactFaces().begin(), p0->getContactFaces().end(), [&](const auto &F) { return F->getNetwork() == PasObj; }) &&
                std::any_of(p1->getContactFaces().begin(), p1->getContactFaces().end(), [&](const auto &F) { return F->getNetwork() == PasObj; }) &&
                std::any_of(p2->getContactFaces().begin(), p2->getContactFaces().end(), [&](const auto &F) { return F->getNetwork() == PasObj; })) {
               this->PressureVeticies.push_back({{p0->pressure, p1->pressure, p2->pressure}, ToX(f)});
               this->actingFaces.emplace_back(f);
               count++;
            }
         }
      for (const auto &[P012, X012] : this->PressureVeticies) {
         auto intpX = interpolationTriangleLinear0101(X012);
         for (const auto &[x0, x1, w0w1] : __GWGW10__Tuple)
            area += intpX.J(x0, x1) * w0w1;
      }
      std::cout << "Êé•Ëß¶„Åó„Å¶„ÅÑ„ÇãÈù¢„ÅÆÊï∞:" << count << std::endl;
      std::cout << "Ë°®Èù¢Á©ç:" << area << std::endl;
   };

   Tddd getFroudeKrylovTorque(const Tddd &COM) {
      /*
      cross„ÅÆÂºïÊï∞„ÅÆÈ†ÜÁï™„Å´Ê≥®ÊÑè
      „É¢„Éº„É°„É≥„Éà„ÅÆË®àÁÆó„ÅåÔºåN=rxP
      */
      this->torque = {0., 0., 0.};
      for (const auto &[P012, X012] : this->PressureVeticies) {
         auto intpP = interpolationTriangleLinear0101(P012);
         auto intpX = interpolationTriangleLinear0101(X012);
         auto n = TriangleNormal(X012);
         for (const auto &[x0, x1, w0w1] : __GWGW10__Tuple)
            this->torque += Cross(intpX(x0, x1) - COM, n * intpP(x0, x1)) * intpX.J(x0, x1) * w0w1;
      }
      return this->torque;
   };

   Tddd surfaceIntegralOfPressure() {
      this->force = {0., 0., 0.};
      for (const auto &[P012, X012] : this->PressureVeticies) {
         auto intpP = interpolationTriangleLinear0101(P012);
         auto intpX = interpolationTriangleLinear0101(X012);
         auto n = TriangleNormal(X012);
         for (const auto &[x0, x1, w0w1] : __GWGW10__Tuple)
            this->force += n * intpP(x0, x1) * intpX.J(x0, x1) * w0w1;
      }
      return this->force;
   };
};

struct BEM_BVP {
   // std::unordered_set<networkPoint *> Points;
   // std::unordered_set<networkFace *> Faces;
   const bool Neumann = false;
   const bool Dirichlet = true;

#if defined(use_lapack)
   lapack_lu *lu;
#else
   ludcmp_parallel *lu;
#endif

   using T_PBF = std::tuple<netP *, bool, netF *>;
   using mapTPBF_Tdd = std::map<T_PBF, Tdd>;
   using mapTPBF_mapTPBF_Tdd = std::map<T_PBF /*„Çø„Éó„É´*/, mapTPBF_Tdd>;
   using map_P_Vd = std::map<netP *, V_d>;
   //@ ÂêÑ„Éê„Ç±„ÉÑ„Åß„ÅÆ„É¢„Éº„É°„É≥„Éà„ÇíÊ¨°Êï∞Âà•„Å´‰øùÂ≠ò„Åô„ÇãÔºé(„É¶„Éã„Éº„ÇØ) p->{k,m,Yn,Y}„Éô„ÇØ„Éà„É´
   using uo_P_uoTiiTdd = std::unordered_map<networkPoint *, std::unordered_map<Tii /*k,m*/, Tdd /*YYn*/>>;
   using V_uo_P_uoTiiTdd = std::vector<uo_P_uoTiiTdd>;
   using VV_uo_P_uoTiiTdd = std::vector<V_uo_P_uoTiiTdd>;
   using VVV_uo_P_uoTiiTdd = std::vector<VV_uo_P_uoTiiTdd>;
   VV_d mat_ukn, mat_kn;
   V_d knowns;
   std::vector<std::vector<Tdd>> IGIGn;
   BEM_BVP() : lu(nullptr){};
   ~BEM_BVP() {
      if (this->lu) delete this->lu;
   };
   //% ------------------------------------------------------------------------------ */
   //%                             solve phi_t and phi_n_t                            */
   //% ------------------------------------------------------------------------------ */
   void setPhiPhin_t() const {
#ifdef derivatives_debug
      std::cout << "œÜt„Å®œÜnt„Çí‰∏ÄÈÉ®Ë®àÁÆóüëá" << std::endl;
#endif

#ifdef _OPENMP
#pragma omp parallel
#endif
      for (const auto &[PBF, i] : PBF_index)
#ifdef _OPENMP
#pragma omp single nowait
#endif
      {
         auto [p, B, F] = PBF;
         //% ------------------------------------------------------ */
         //%                 „Éá„Ç£„É™„ÇØ„É¨Â¢ÉÁïåÈù¢‰∏ä„ÅÆœÜt„ÇíË®àÁÆó                */
         //% ------------------------------------------------------ */
         //!!„Éé„Ç§„Éû„É≥„ÅÆÂ†¥Âêà„ÅØ„Åì„Çå„ÅßDphiDt„ÅØË®àÁÆó„Åß„Åç„Åæ„Åõ„Çì„Çà
         if (p->Dirichlet || p->CORNER)
            std::get<0>(p->phiphin_t) = p->aphiat(0.);
         // std::get<0>(p->phiphin_t) = p->DphiDt(0.) - Dot(p->U_BEM, p->U_BEM);
         //% ------------------------------------------------------ */
         //%    „Éé„Ç§„Éû„É≥Â¢ÉÁïåÈù¢‰∏ä„ÅÆÂä†ÈÄüÂ∫¶„Åã„Çâ,„Éé„Ç§„Éû„É≥Â¢ÉÁïåÈù¢‰∏ä„ÅÆœÜnt„ÇíË®àÁÆó     */
         //% ------------------------------------------------------ */
         if (p->Neumann || p->CORNER) {
            /* ‚àáU=‚àá‚àáf={{fxx, fyx, fzx},{fxy, fyy, fzy},{fxz, fyz, fzz}}, ‚àá‚àáf=‚àá‚àáf^T */
            // b* p->phintOnFace„ÅØÔºåstd::unordered_map<networkFace *, double>
            // b* ÁØÄÁÇπ„ÅÆphin„Çí‰øùÂ≠ò„Åô„ÇãÔºé„Åæ„ÅüÔºåÂ§öÈáçÁØÄÁÇπ„Åã„Å©„ÅÜ„Åã„ÇÇÔºåÈù¢„Åånullptr„Åã„Å©„ÅÜ„Åã„ÅßÂà§Âà•„Åß„Åç„ÇãÔºé
            // b* setBoundaryConditions„ÅßÊ±∫„ÇÅ„Å¶„ÅÑ„ÇãÔºé
            auto n = p->getNormalNeumann_BEM();
            auto Q = Quaternion();
            for (auto &[f, phin_t] : p->phintOnFace) {
               if (f) {
                  auto netInContact = NearestContactFace(f)->getNetwork();
                  auto w = netInContact->velocityRotational();
                  auto dQdt = Q.d_dt(w);
                  auto U = uNeumann(p, f);
                  // phin_t = std::get<1>(p->phiphin_t) = Dot(n, Dot(uNeumann(p, f) - grad_phi, dQdt.Rv()) + accelNeumann(p, f) - Dot(grad_phi, grad_U_LinearElement(f)));
                  // phin_t = std::get<1>(p->phiphin_t) = Dot(w, U - p->U_BEM) + Dot(n, accelNeumann(p, f) - Dot(U, Hessian));
                  // phin_t = std::get<1>(p->phiphin_t) = Dot(w, U - p->U_BEM) + Dot(n, accelNeumann(p, f) - Dot(U, Hessian));
                  //
                  phin_t = std::get<1>(p->phiphin_t) = Dot(w, U - p->U_BEM) + Dot(n, accelNeumann(p, f));
                  //
                  auto s0s1s2 = OrthogonalBasis(f->normal);
                  auto [s0, s1, s2] = s0s1s2;
                  auto Hessian = grad_U_LinearElement(f, s0s1s2);
                  phin_t -= std::get<0>(Dot({Dot(U, s0), Dot(U, s1), Dot(U, s2)}, Hessian));
                  //
                  // phin_t = std::get<1>(p->phiphin_t) = Dot(w, uNeumann(p, f) - p->U_BEM) + Dot(n, accelNeumann(p, f) - Dot(p->U_BEM, grad_U_LinearElement(f)));
               } else {
                  auto netInContact = NearestContactFace(p)->getNetwork();
                  auto w = netInContact->velocityRotational();
                  auto dQdt = Q.d_dt(w);
                  // phin_t = std::get<1>(p->phiphin_t) = Dot(n, Dot(uNeumann(p) - p->U_BEM, dQdt.Rv()) + accelNeumann(p) - Dot(p->U_BEM, grad_U_LinearElement(p)));
                  auto U = uNeumann(p);
                  // phin_t = std::get<1>(p->phiphin_t) = Dot(w, U - p->U_BEM) + Dot(n, accelNeumann(p) - Dot(U, Hessian));
                  //
                  phin_t = std::get<1>(p->phiphin_t) = Dot(w, U - p->U_BEM) + Dot(n, accelNeumann(p));
                  //
                  auto s0s1s2 = OrthogonalBasis(p->getNormal_BEM());
                  auto [s0, s1, s2] = s0s1s2;
                  auto Hessian = grad_U_LinearElement(p, s0s1s2);
                  phin_t -= std::get<0>(Dot({Dot(U, s0), Dot(U, s1), Dot(U, s2)}, Hessian));
               }
            }
         }
      }
   };
   /* ------------------------------------------------------ */
   bool isTarget(Network *net) const {
      // return true;
      if (net->inputJSON.find("velocity") && net->inputJSON.at("velocity")[0] == "floating")
         // if (net->inputJSON.find("RigidBody"))
         return true;
      else
         return false;
   };
   /* ------------------------------------------------------ */
   V_d Func(V_d ACCELS_IN, const Network *water, const std::vector<Network *> &rigidbodies) const {
      auto ACCELS = ACCELS_IN;
      {
         int i = 0;
         for (const auto &net : rigidbodies)
            if (isTarget(net))
               for_each(net->acceleration, [&](auto &a_w) { a_w = ACCELS_IN[i++]; });
      }

      //* --------------------------------------------------- */
      //*                  Âä†ÈÄüÂ∫¶ --> phiphin_t                */
      //* --------------------------------------------------- */
      setPhiPhin_t();
      V_d knowns(PBF_index.size());
      for (const auto &[PBF, i] : PBF_index) {
         auto [p, DorN, f] = PBF;
         if (DorN == Dirichlet)
            knowns[i] = std::get<0>(p->phiphin_t);
         else
            knowns[i] = p->phintOnFace.at(f);  // „ÅØ„ÅÑ„Å£„Å¶„Å™„ÅÑÔºü„ÅØ„ÅÑ„Å£„Å¶„ÅüÔºé
      }

      V_d phiORphin_t(PBF_index.size());
      std::cout << "Âä†ÈÄüÂ∫¶ --> phiphin_t" << std::endl;

#if defined(use_CG)
      GradientMethod gd(mat_ukn);
      phiORphin_t = gd.solve(Dot(mat_kn, knowns));
#elif defined(use_gmres)
      std::cout << "gmres for phiphin_t" << std::endl;
      gmres gm(mat_ukn /*Êú™Áü•„ÅÆË°åÂàó‰øÇÊï∞ÔºàÂ∑¶Ëæ∫Ôºâ*/, Dot(mat_kn, knowns) /*Êó¢Áü•„ÅÆ„Éô„ÇØ„Éà„É´ÔºàÂè≥Ëæ∫Ôºâ*/, phiORphin_t /*Ëß£*/, use_gmres);
      phiORphin_t = gm.x;
      if (!isFinite(gm.err)) {
         std::cout << "gm.err = " << gm.err << std::endl;
         this->lu->solve(Dot(mat_kn, knowns) /*Êó¢Áü•„ÅÆ„Éô„ÇØ„Éà„É´ÔºàÂè≥Ëæ∫Ôºâ*/, phiORphin_t /*Ëß£*/);
      }
      // auto err = Norm(Dot(mat_ukn, gm.x) - Dot(mat_kn, knowns));
      // gmres gm(mat_ukn /*Êú™Áü•„ÅÆË°åÂàó‰øÇÊï∞ÔºàÂ∑¶Ëæ∫Ôºâ*/, Dot(mat_kn, knowns) /*Êó¢Áü•„ÅÆ„Éô„ÇØ„Éà„É´ÔºàÂè≥Ëæ∫Ôºâ*/, phiORphin_t /*Ëß£*/, 5);
      // auto err = Norm(Dot(mat_ukn, gm.x) - Dot(mat_kn, knowns));
      // std::cout << err << std::endl;
      // /* ------------------------------------------------------ */
      // if (isFinite(err) && err < 0.1)
      // else
      //
#elif defined(use_lapack)
      this->lu->solve(Dot(mat_kn, knowns) /*Êó¢Áü•„ÅÆ„Éô„ÇØ„Éà„É´ÔºàÂè≥Ëæ∫Ôºâ*/, phiORphin_t /*Ëß£*/);
#endif
      std::cout << "solved" << std::endl;
      //* --------------------------------------------------- */
      //*                 phiphin_t --> ÂúßÂäõ                   */
      //* --------------------------------------------------- */
      // for (const auto &[PBF, i] : PBF_index) {
      //    auto [p, DorN, f] = PBF;
      //    if (DorN == Dirichlet)
      //       std::get<1>(p->phiphin_t) = phiORphin_t[i];
      //    else
      //       std::get<0>(p->phiphin_t) = phiORphin_t[i];
      //    p->pressure = p->pressure_BEM = -_WATER_DENSITY_ * (std::get<0>(p->phiphin_t) + _GRAVITY_ * p->height() + Dot(p->U_BEM, p->U_BEM) / 2.);
      // }
      /* -------------------------------------------------------------------------- */
      for (const auto &[PBF, i] : PBF_index) {
         auto [p, DorN, f] = PBF;
         if (DorN == Dirichlet) {
            // do nothing
         } else if (p->phintOnFace.size() > 1) {
            std::get<0>(p->phiphin_t) = 0;
            std::get<1>(p->phiphin_t) = 0;
         } else
            std::get<0>(p->phiphin_t) = 0;
      }

      for (const auto &[PBF, i] : PBF_index) {
         auto [p, DorN, f] = PBF;
         if (DorN == Dirichlet)
            std::get<1>(p->phiphin_t) = phiORphin_t[i];
         else if (p->phintOnFace.size() > 1) {
            double total = 0;
            for (auto [f, phin_t] : p->phintOnFace)
               total += f->area;
            std::get<0>(p->phiphin_t) += phiORphin_t[i] * f->area / total;
            std::get<1>(p->phiphin_t) += p->phintOnFace.at(f) * f->area / total;
         } else {
            std::get<0>(p->phiphin_t) = phiORphin_t[i];
            std::get<1>(p->phiphin_t) = p->phintOnFace.at(f);
         }
      }
      /* -------------------------------------------------------------------------- */
      // // Ë∂≥„ÅóÂêà„Çè„Åõ„Çã„ÅÆ„ÅßÂàùÊúüÂåñ
      // for (const auto &[PBF, i] : PBF_index) {
      //    auto [p, DorN, f] = PBF;
      //    if (DorN == Neumann)
      //       std::get<0>(p->phiphin_t) = 0;
      // }
      // //
      // for (const auto &[PBF, i] : PBF_index) {
      //    auto [p, DorN, f] = PBF;
      //    if (DorN == Dirichlet)
      //       std::get<1>(p->phiphin_t) = phiORphin_t[i];
      //    else if (p->phinOnFace.size() > 1) {
      //       double total = 0;
      //       for (auto [f, phin] : p->phinOnFace)
      //          total += f->area;

      //       std::get<0>(p->phiphin_t) += phiORphin_t[i] * f->area / total;
      //    } else
      //       std::get<0>(p->phiphin_t) = phiORphin_t[i];
      // }

      for (const auto &[PBF, i] : PBF_index) {
         auto [p, DorN, f] = PBF;
         p->pressure = p->pressure_BEM = -_WATER_DENSITY_ * (std::get<0>(p->phiphin_t) + _GRAVITY_ * p->height() + Dot(p->U_BEM, p->U_BEM) / 2.);
      }

      //* --------------------------------------------------- */
      //*                     ÂúßÂäõ ---> Âä†ÈÄüÂ∫¶                  */
      //* --------------------------------------------------- */
      int i = 0;
      for (const auto &net : rigidbodies)
         if (isTarget(net)) {
            // std::cout << net->inputJSON.find("velocity") << std::endl;
            // std::cout << net->inputJSON["velocity"][0] << std::endl;
            auto tmp = calculateFroudeKrylovForce(water->getFaces(), net);
            auto [mx, my, mz, Ix, Iy, Iz] = net->getInertiaGC();
            auto force = tmp.surfaceIntegralOfPressure() + _GRAVITY3_ * net->mass;
            auto torque = tmp.getFroudeKrylovTorque(net->COM);
            auto [a0, a1, a2] = force / Tddd{mx, my, mz};
            auto [a3, a4, a5] = torque / Tddd{Ix, Iy, Iz};
            // net->acceleration = T6d{a0, a1, a2, a3, a4, a5};
            for_each(T6d{a0, a1, a2, a3, a4, a5}, [&](const auto &a_w) { ACCELS[i++] = a_w; });
         }
      return ACCELS - ACCELS_IN;
   };
   /* ------------------------------------------------------ */

   void solveForPhiPhin_t(const Network *water, const std::vector<Network *> &rigidbodies) const {

      //@ --------------------------------------------------- */
      //@        Âä†ÈÄüÂ∫¶ --> phiphin_t --> ÂúßÂäõ --> Âä†ÈÄüÂ∫¶        */
      //@ --------------------------------------------------- */
      V_d ACCELS_init, ACCELS, ACCELS_old, ACCELS_old_old;

      // read --> acceleration
      for (const auto &net : rigidbodies) {
         if (net->inputJSON.find("velocity") && net->inputJSON.at("velocity")[0] == "floating") {
            if (net->inputJSON.at("velocity").size() > 1) {
               std::cout << Red << "net->inputJSON[\" velocity \"][1] = " << net->inputJSON.at("velocity")[1] << colorOff << std::endl;
               double start_time = std::stod(net->inputJSON.at("velocity")[1]);
               std::cout << Red << "start_time = " << start_time << colorOff << std::endl;
               if (real_time < start_time) {
                  for_each(net->acceleration, [&](auto &a_w) { a_w = 0.; });
               } else
                  for_each(net->acceleration, [&](const auto &a_w) { ACCELS_init.emplace_back(a_w); });
            } else
               for_each(net->acceleration, [&](const auto &a_w) { ACCELS_init.emplace_back(a_w); });
         } else
            for_each(net->acceleration, [&](auto &a_w) { a_w = 0.; });
      }

      if (ACCELS_init.empty()) {
         setPhiPhin_t();
         return;
      }

      auto tmp = ACCELS_init;
      tmp[0] += 1E-10;
      BroydenMethod BM(ACCELS_init, tmp);
      for (auto j = 0; j < 20; ++j) {

         auto func_ = Func(BM.X - BM.dX, water, rigidbodies);
         std::cout << "func_ = " << func_ << std::endl;
         auto func = Func(BM.X, water, rigidbodies);
         std::cout << "func = " << func_ << std::endl;
         BM.update(func, func_, j < 1 ? 1E-10 : 1.);
         // for (const auto &net : rigidbodies)
         //    if (isTarget(net))
         //       for_each(net->acceleration, [&](auto &a_w) { a_w = BM.X[i++]; });

         // save --> acceleration
         int i = 0;
         for (const auto &net : rigidbodies) {
            if (net->inputJSON.find("velocity") && net->inputJSON.at("velocity")[0] == "floating") {
               if (net->inputJSON.at("velocity").size() > 1) {
                  std::cout << Red << "net->inputJSON[\" velocity \"][1] = " << net->inputJSON.at("velocity")[1] << colorOff << std::endl;
                  double start_time = std::stod(net->inputJSON.at("velocity")[1]);
                  std::cout << Red << "start_time = " << start_time << colorOff << std::endl;
                  if (real_time < start_time) {
                     for_each(net->acceleration, [&](auto &a_w) { a_w = 0.; });
                  } else
                     for_each(net->acceleration, [&](auto &a_w) { a_w = BM.X[i++]; });
               } else
                  for_each(net->acceleration, [&](auto &a_w) { a_w = BM.X[i++]; });
            } else
               for_each(net->acceleration, [&](auto &a_w) { a_w = 0.; });
         }

         std::cout << "j = " << j << ", " << Red << Norm(func) << colorOff << std::endl;
         std::cout << Red << "func_ = " << func_ << colorOff << std::endl;
         std::cout << Red << "func = " << func << colorOff << std::endl;
         std::cout << Red << "BM.X = " << BM.X << colorOff << std::endl;
         std::cout << Red << "BM.dX = " << BM.dX << colorOff << std::endl;

         if (Norm(func) < 1E-10)
            break;
      }
   };

   //% -------------------------------------------------------------------------- */
   //%                             solve phi and phi_n                            */
   //% -------------------------------------------------------------------------- */

   void solve(const Network &water, const Buckets<networkPoint *> &FMM_BucketsPoints, const Buckets<networkFace *> &FMM_BucketsFaces) {
      //* ------------------------------------------------------ */
      //%                     ÂêÑÁÇπ„ÅßÊñπÁ®ãÂºè„Çí‰Ωú„ÇãÂ†¥Âêà                 */
      //* ------------------------------------------------------ */
      std::cout << "ÂêÑÁÇπ„ÅßÊñπÁ®ãÂºè„Çí‰Ωú„ÇãÂ†¥Âêà" << std::endl;
      PBF_index.clear();
      PBF_index.reserve(3 * water.getPoints().size());
      int i = 0;
      for (const auto &p : water.getPoints()) {
         if (p->Dirichlet || p->CORNER)
            PBF_index[{p, Dirichlet, nullptr}] = i++;
         //! PBF_index„ÅÆNeuamnnÁÆáÊâÄ„Å´Èñ¢„Åó„Å¶„ÅØÔºåË®≠ÂÆöÊ∏à„Åø„ÅÆ„ÄÄp->phinOnFace„ÄÄ„ÅÆÁä∂ÊÖã„Å´„Å´‰ªª„Åõ„Çã
         for (const auto &[f, _] : p->phinOnFace)
            PBF_index[{p, Neumann, f}] = i++;
      }

      std::cout << Red << "water.getPoints() = " << i << std::endl;
      IGIGn = std::vector<std::vector<Tdd>>(PBF_index.size(), std::vector<Tdd>(PBF_index.size(), {0., 0.}));
      mat_kn = mat_ukn = VV_d(PBF_index.size(), V_d(PBF_index.size(), 0.));

      auto PF2index = [&](netP *p, netF *integ_f) {
         auto it = PBF_index.find({p, integ_f->Dirichlet, integ_f});
         if (it != PBF_index.end())
            return it->second;
         else
            return PBF_index[{p, integ_f->Dirichlet, nullptr}];
      };

#define use_rigid_mode
      Timer timer;
      std::cout << "ÂéüÁÇπ„ÇíÁØÄÁÇπ„Å´„Å®„ÇäÔºåÊñπÁ®ãÂºè„Çí‰ΩúÊàêÔºé‰∏¶ÂàóÂåñ" << std::endl;
      std::cout << Magenta << timer() << colorOff << std::endl;
#ifdef _OPENMP
#pragma omp parallel
#endif
      for (const auto &[PBF, index] : PBF_index)
#ifdef _OPENMP
#pragma omp single nowait
#endif
      {
         auto [origin, _, __] = PBF;
         auto it = PBF_index.begin();
         double origin_ign_rigid_mode = 0.;
         auto &IGIGn_Row = IGIGn[index];
         std::array<std::tuple<netP *, Tdd>, 3> ret;
         Tdd IGIGn, c;
         double nr, tmp;
         Tddd X2, X0, X1, A, cross;
         for (const auto &integ_f : FMM_BucketsFaces.all_stored_objects) {
            {
               const auto [p0, p1, p2] = integ_f->getPoints(origin);
               // ret = {{p0, {0., 0.}}, {p1, {0., 0.}}, {p2, {0., 0.}}};
               ret = {{{p0, {0., 0.}}, {p1, {0., 0.}}, {p2, {0., 0.}}}};
               X2 = p2->getXtuple();
               X0 = p0->getXtuple() - X2;
               X1 = p1->getXtuple() - X2;
               A = origin->getXtuple() - X2;
               cross = Cross(X0, X1);
               c = {Norm(cross), Dot(A, cross)};
               if (origin == p0 || origin == p1 || origin == p2)
                  std::get<1>(c) = 0;

               // for_each(__GW5xGW5__, [&](const auto &GWGW) {
               //    tmp = std::get<2>(GWGW) * (1. - std::get<0>(GWGW)) / (nr = Norm(X0 * std::get<0>(GWGW) + X1 * std::get<1>(GWGW) * (1. - std::get<0>(GWGW)) - A));
               //    std::get<1>(std::get<0>(ret)) += (IGIGn = {tmp, tmp / (nr * nr)}) * std::get<0>(GWGW);
               //    std::get<1>(std::get<1>(ret)) += IGIGn * std::get<1>(GWGW) * (1. - std::get<0>(GWGW));
               //    std::get<1>(std::get<2>(ret)) += IGIGn * (-1. + std::get<0>(GWGW)) * (-1. + std::get<1>(GWGW));
               // });
               //

               for_each(__array_GW5xGW5__, [&](const auto &GWGW) {
                  tmp = std::get<2>(GWGW) * (1. - std::get<0>(GWGW)) / (nr = Norm(X0 * std::get<0>(GWGW) + X1 * std::get<1>(GWGW) * (1. - std::get<0>(GWGW)) - A));
                  std::get<1>(std::get<0>(ret)) += (IGIGn = {tmp, tmp / (nr * nr)}) * std::get<0>(GWGW);           // Ë£úÈñìÊ∑ªÂ≠ó0
                  std::get<1>(std::get<1>(ret)) += IGIGn * std::get<1>(GWGW) * (1. - std::get<0>(GWGW));           // Ë£úÈñìÊ∑ªÂ≠ó1
                  std::get<1>(std::get<2>(ret)) += IGIGn * (-1. + std::get<0>(GWGW)) * (-1. + std::get<1>(GWGW));  // Ë£úÈñìÊ∑ªÂ≠ó2
               });

               std::get<1>(std::get<0>(ret)) *= c;
               std::get<1>(std::get<1>(ret)) *= c;
               std::get<1>(std::get<2>(ret)) *= c;
            }
            for_each(ret, [&](const auto &p_igign) {
               /*
               „Åì„ÅÆ„É´„Éº„Éó„Åß„ÅØÔºå
               „ÅÇ„ÇãÈù¢integ_f„Å´Èö£Êé•„Åô„ÇãÁØÄÁÇπ{p0,p1,p2}„ÅÆÂàó,IGIGn[origin(fixed),p0],...„Å´ÂÄ§„ÅåËøΩÂä†„Åï„Çå„Å¶„ÅÑ„ÅèÔºé
               Ôºàp0„ÅåÂ§öÈáçÊé•ÁÇπ„ÅÆÂ†¥ÂêàÔºåÈÅ©Âàá„Å´p0„Å®Âêå„Åò‰ΩçÁΩÆ„Å´Âà•„ÅÆÂ§âÊï∞„ÅåË®≠ÂÆö„Åï„Çå„Å¶„Åä„ÇäÔºåÂà•„ÅÆÈù¢„ÅÆÁ©çÂàÜ„ÅÆÈöõ„Å´q0„ÅåÂèÇÁÖß„Åï„Çå„ÇãÔºéÔºâ
               //
               p0„ÅØÔºå{Èù¢,Ë£úÈñìÊ∑ªÂ≠ó}„ÅßÊ±∫ÂÆö„Åô„Çã„Åì„Å®„ÇÇ„Åß„Åç„ÇãÔºé
               {Èù¢,Ë£úÈñìÊ∑ªÂ≠ó0}->p0,{Èù¢,Ë£úÈñìÊ∑ªÂ≠ó1}->p1,{Èù¢,Ë£úÈñìÊ∑ªÂ≠ó2}->p2„Å®„ÅÑ„ÅÜ„Çà„ÅÜ„Å´Ôºé
               //
               //@ Â§öÈáçÁØÄÁÇπÔºö
               {Èù¢A,Ë£úÈñìÊ∑ªÂ≠ó},{Èù¢B,Ë£úÈñìÊ∑ªÂ≠ó},{Èù¢C,Ë£úÈñìÊ∑ªÂ≠ó}„ÅåÂÖ®„Å¶Âêå„ÅòÁØÄÁÇπp0„ÇíÊåá„Åó„Å¶„ÅÑ„Åü„Å®„Åô„ÇãÔºé
               ÊôÆÈÄö„ÅÆÁØÄÁÇπ„Å™„ÇâÔºåIGIGn[origin,{p0,nullptr}]„ÇíÊåá„ÅôÔºé
               Â§öÈáçÁØÄÁÇπ„Å™„ÇâÔºåIGIGn[origin,{p0,Èù¢A}],IGIGn[origin,{p0,Èù¢B}]„ÇíÊåá„Åô„Çà„ÅÜ„Å´„Åô„ÇãÔºé
               „Åì„ÅÆÊìç‰Ωú„ÇíË®ÄËëâ„ÅßË®Ä„ÅÑÊèõ„Åà„Çã„Å®Ôºå
               „Äån„Åå‰∏çÈÄ£Á∂ö„Å´Â§âÂåñ„Åô„ÇãÁÇπ„Åß„ÅØÔºå„Åù„ÅÆÁÇπ„ÅÆÈö£Êé•Èù¢„Å´„Åù„Çå„Åû„ÇåÂØæ„Åó„Å¶œÜn„ÇíÊ±Ç„ÇÅ„Çã„Åπ„Åç„Åß„ÅÇ„ÇãÔºàœÜ„ÅØÂêå„Åò„Åß„ÇÇÔºâÔºé„Äç
               „Äån„Åå‰∏çÈÄ£Á∂ö„Å´Â§âÂåñ„Åô„ÇãÁÇπ„Åß„ÅØÔºå„Å©„ÅÆÈù¢„ÇíÁ©çÂàÜ„Åô„Çã„Åã„Å´Âøú„Åò„Å¶ÔºåÂèÇÁÖß„Åô„ÇãœÜn„ÇíÂå∫Âà•„ÅóÂàá„ÇäÊõø„Åà„ÇãÂøÖË¶Å„Åå„ÅÇ„ÇãÔºé„Äç
               //
               //@ „Åï„Å¶Ôºå„Åì„ÅÆÊÆµÈöé„Åßp0„ÅåÂ§öÈáçÁØÄÁÇπ„Åß„ÅÇ„Çã„Åã„Å©„ÅÜ„ÅãÂà§Êñ≠„Åß„Åç„Çã„Å†„Çç„ÅÜ„ÅãÔºü
               {ÁØÄÁÇπÔºåÈù¢}-> Âàó„Éô„ÇØ„Éà„É´„ÅÆ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ „ÇíÊ±∫„ÇÅ„Çå„Çã„ÅãÔºü
               //
               Èù¢„ÇíÂå∫Âà•„Åô„Çã„Åã„Å©„ÅÜ„Åã„ÅåÂÖà„Å´„Çè„Åã„Çâ„Å™„ÅÑ„ÅÆ„ÅßÔºåface*„ÅÆ„Åæ„Åæ„Åãnullptr„Å®„Åô„Åπ„Åç„Åã„Çè„Åã„Çâ„Å™„ÅÑ„Å®„ÅÑ„ÅÜ„Åì„Å®ÔºéÔºéÔºéÔºé
               //
               PBF_index[{p, Dirichlet, „ÅÇ„ÇãË¶ÅÁ¥†}]
               „ÅØÂ≠òÂú®„Åó„Å™„ÅÑ„Å†„Çç„ÅÜÔºéDirichletÁØÄÁÇπ„ÅØÔºå{p, „ÅÇ„ÇãË¶ÅÁ¥†}„Åã„Çâ„ÅÆÂØÑ‰∏é„ÇíÔºå„ÅÇ„ÇãÈù¢„Å´
               */
               auto [p, igign] = p_igign;
               IGIGn_Row[PF2index(p, integ_f)] += igign;        // „Åì„ÅÆÈù¢„Å´Èñ¢„Åô„ÇãÁ©çÂàÜ„Å´„Åä„ÅÑ„Å¶ÔºåœÜ„Åæ„Åü„ÅØœÜn„ÅÆÂØÑ‰∏é
               if (p != origin)                                 // for use_rigid_mode
                  origin_ign_rigid_mode -= std::get<1>(igign);  // for use_rigid_mode
            });
         }
         /* -------------------------------------------------------------------------- */
#if defined(use_rigid_mode)
         std::get<1>(IGIGn_Row[index]) = origin_ign_rigid_mode;
#else
         /*
         @ ‚àá^2(1/r)=-1/(4pi)Œ¥(r)
         @ IG*œÜn=-aœÜ+IGn*œÜ
         @ IG*œÜn=(IGn-a)*œÜ
         */
         std::get<1>(IGIGn_Row[index]) += origin->getSolidAngle();
#endif
      }
      //
      std::cout << Green << "Èõ¢Êï£Âåñ„Å´„Åã„Åã„Å£„ÅüÊôÇÈñì" << timer() << colorOff << std::endl;
      /* ------------------------------------------------------ */
      // #define quad_element
#define linear_element
      // #define liear_and_quad_element

      std::cout << "‰∏¶ÂàóÂåñ DONE" << std::endl;
      std::cout << "2„Å§„ÅÆ‰øÇÊï∞Ë°åÂàó„ÅÆÊÉÖÂ†±„ÇíÊåÅ„Å§„ÄÄP_P_IGIGn„ÄÄ„ÇíÂ¢ÉÁïåÊù°‰ª∂„Å´Âøú„Åò„Å¶ÂÖ•„ÇåÊõø„Åà„ÇãÔºàÁßªÈ†ÖÔºâ:" << std::endl;

      {
         // b@ ------------------------------------------------------ */
         // b@                 Á≥ªÊï∞Ë°åÂàómat_uknÔºémat_kn„ÅÆË®àÁÆó             */
         // b@ ------------------------------------------------------ */
#ifdef _OPENMP
#pragma omp parallel
#endif
         for (const auto &[PBF, i] : PBF_index)
#ifdef _OPENMP
#pragma omp single nowait
#endif
         {
            /*@ mat_ukn, mat_kn, vec_P
              +--+--+--+
            | |--+--+--|
            V |--+--+--|
              +--+--+--+
            */
            auto [p, DorN, f] = PBF;
            // auto &IGIGn_Row = IGIGn[i];
            // p->IGIGn[vec_P[i]]; // PBF_PBF_IGIGn.at(vec_P[i]);
            /* mat_ukn, mat_kn, vec_P
                ====>
              +--+--+--+
              |--+--+--|
              |--+--+--|
              +--+--+--+
            */
            // if (!(p->CORNER && DorN == Neumann /*Â§âÊõ¥„Åô„ÇãÂØæË±°„ÅÆË°å*/))  //! OK
            {
               Tdd igign;
               for (const auto &[PBF_j, j] : PBF_index) {
                  igign = IGIGn[i][j];
                  // Êú™Áü•Â§âÊï∞„ÅÆ‰øÇÊï∞Ë°åÂàó„ÅØÂ∑¶ÔºåÊó¢Áü•Â§âÊï∞„ÅÆ‰øÇÊï∞Ë°åÂàó„ÅØÂè≥
                  if (std::get<1>(PBF_j) == Neumann)
                     igign = {-std::get<1>(igign), -std::get<0>(igign)};
                  /*
                  IGIGn „ÅØ Â∑¶Ëæ∫„Å´ IG*œÜn „ÅåÂè≥Ëæ∫„Å´ IGn*œÜ „ÅåÊù•„Çã„Çà„ÅÜ„Å´Ë®àÁÆó„Åó„Å¶„ÅÑ„Çã„Åü„ÇÅÔºåÁßªÈ†Ö„Åô„ÇãÂ†¥ÂêàÔºåÁ¨¶Âè∑„ÇíÂ§â„Åà„ÇãÂøÖË¶Å„Åå„ÅÇ„ÇãÔºé
                  IG*œÜn = IGn*œÜ
                  ÁßªÈ†ÖÂâç:{IG0,IG1,IG2,IG3} . {œÜn0,œÜn1,œÜn2,œÜn3} = {IGn0,IGn1,IGn2,IGn3} . {œÜ0,œÜ1,œÜ2,œÜ3}
                  ÁßªÈ†ÖÂæå:{IG0,-IGn1,IG2,IG3} . {œÜn0,œÜ1,œÜn2,œÜn3} = {IGn0,-IG1,IGn2,IGn3} . {œÜ0,œÜn1,œÜ2,œÜ3}
                  */
                  mat_ukn[i][j] = std::get<0>(igign);
                  mat_kn[i][j] = std::get<1>(igign);
               }
            }
         }

         /* ------------------------------------------------------ */
         double maxpp = 0;
         for (auto i = 0; i < mat_ukn.size(); ++i) {
            // LU„Åô„Çã„ÅÆ„ÅØmat_ukn„Å†„Åë„Å™„ÅÆ„ÅßÔºåmat_kn„ÅÆÊúÄÂ§ßÂÄ§„Çí‰Ωø„ÅÜÂøÖË¶Å„ÅØ„Å™„ÅÑ
            if (maxpp < std::abs(mat_ukn[i][i]))
               maxpp = std::abs(mat_ukn[i][i]);
         }
         /* ------------------------------------------------------ */
         knowns = V_d(PBF_index.size());  //! ok
                                          //! Points„ÅÆÈ†ÜÁï™„Å®Âêà„Çè„Åõ„Å¶„Å®„Çã„Çà„ÅÜ„Å´Ê≥®ÊÑè

#ifdef _OPENMP
#pragma omp parallel
#endif
         for (const auto &[PBF, i] : PBF_index)
#ifdef _OPENMP
#pragma omp single nowait
#endif
         {
            auto [p, DorN, f] = PBF;
            // auto &PBF_IGIGn = IGIGn[i];
            // „Éá„Ç£„É™„ÇØ„É¨„ÅÆËßíÁÇπ„Å†„Åë„ÅåÁ©çÂàÜ„Åó„Åü‰øÇÊï∞„Çí‰Ωø„Å£„ÅüÊñπÁ®ãÂºè„Çí‰Ωø„ÅÜÔºé
            // if (DorN == Neumann && p->CORNER /*Â§öÈáçÁØÄÁÇπ„ÅÆÊù°‰ª∂*/) {

            /*
               ÁßªÈ†ÖÂâç:{IG0,IG1,IG2,IG3} . {œÜn0,œÜn1,œÜn2,œÜn3} = {IGn0,IGn1,IGn2,IGn3} . {œÜ0,œÜ1,œÜ2,œÜ3}
               ÁßªÈ†ÖÂæå:{IG0,-IGn1,IG2,IG3} . {œÜn0,œÜ1,œÜn2,œÜn3} = {IGn0,-IG1,IGn2,IGn3} . {œÜ0,œÜn1,œÜ2,œÜ3}
               Â§öÈáçÁØÄÁÇπ:{0, 1, 0, 0} . {œÜn0,œÜ1,œÜn2,œÜn3} = {0, 0, 0, 1} . {œÜ0,œÜn1,œÜ2,œÜ3}
            */

            // b$ ------------------------------------------------------ */
            // b$               mat_unknowns, mat_knowns„ÅÆË®àÁÆó            */
            // b$ ------------------------------------------------------ */

            if (DorN == Neumann && p->CORNER /*Â§öÈáçÁØÄÁÇπ„ÅÆÊù°‰ª∂*/) {
               for (const auto &[PBF_j, j] : PBF_index) {
                  auto [p_, DorN_, f_] = PBF_j;
                  if (p == p_) {
                     if (DorN_ == Neumann && f_ == f /*can be nullptr*/) {
                        mat_ukn[i][j] = maxpp;  // œÜ„ÅÆÁ≥ªÊï∞
                        mat_kn[i][j] = 0;       // œÜn„ÅÆÁ≥ªÊï∞
                     } else if (DorN_ == Dirichlet && f_ == nullptr /* there is only one in this row*/) {
                        mat_ukn[i][j] = 0;     // œÜn„ÅÆÁ≥ªÊï∞
                        mat_kn[i][j] = maxpp;  // œÜ„ÅÆÁ≥ªÊï∞ÁßªË°å„Åó„Åü„Åã„Çâ„Éû„Ç§„Éä„ÇπÔºü„ÄÄ„ÅÑ„ÅÑ„ÅàÔºåÁßªÈ†Ö„ÇíËÄÉÊÖÆ„Åó„Åü‰∏ä„Åß„Åì„Çå„Åß„ÅÑ„ÅÑÔºé
                     } else {
                        mat_ukn[i][j] = 0;
                        mat_kn[i][j] = 0;
                     }
                  } else {
                     mat_ukn[i][j] = 0;
                     mat_kn[i][j] = 0;
                  }
               }
            }

            // b$ ------------------------------------------------------ */
            // b$„ÄÄ„ÄÄ„ÄÄ                    knowns„ÅÆË®àÁÆó„ÄÄ                       */
            // b$ ------------------------------------------------------ */
            /*
             * Dot(mat_ukn,phiORphin) = Dot(mat_kn,knowns)
             * => phiORphin = Dot(mat_ukn^-1, Dot(mat_kn,knowns))
             */

            if (DorN == Dirichlet)
               knowns[i] = p->phi_Dirichlet = std::get<0>(p->phiphin);
            else
               knowns[i] = p->phinOnFace.at(f);  // std::get<1>(p->phiphin);

            if (!isFinite(knowns[i])) {
               std::cout << "p->Dirichlet" << p->Dirichlet << std::endl;
               std::cout << "p->CORNER" << p->CORNER << std::endl;
               throw error_message(__FILE__, __PRETTY_FUNCTION__, __LINE__, "knowns is not finite");
            }
         }

         if (!isFinite(mat_ukn))
            throw error_message(__FILE__, __PRETTY_FUNCTION__, __LINE__, "mat_ukn is not finite");
         if (!isFinite(mat_kn))
            throw error_message(__FILE__, __PRETTY_FUNCTION__, __LINE__, "mat_kn is not finite");
      }

      {
         // b% ------------------------------------------------------ */
         // b%                  Â¢ÉÁïåÁ©çÂàÜÊñπÁ®ãÂºè„ÇíËß£„Åè                      */
         // b% ------------------------------------------------------ */
         std::cout << "--------------------- Â¢ÉÁïåÁ©çÂàÜÊñπÁ®ãÂºè„ÇíËß£„Åè ---------------------" << std::endl;
         TimeWatch watch;
         /* ------------------------------------------------------ */
         V_d phiORphin(knowns.size(), 0);
         std::cout << "IGIGn.size()= " << IGIGn.size() << std::endl;
         std::cout << "phiORphin.size()= " << phiORphin.size() << std::endl;
         std::cout << "  mat_kn.size() = " << mat_kn.size() << std::endl;
         //* Êú™Áü•Â§âÊï∞„ÅÆË®àÁÆó
         /* ------------------------------------------------------ */
         // ÂâçÂá¶ÁêÜ
         // auto v = diagonal_scaling_vector(mat_ukn);
         // for (auto i = 0; i < v.size(); ++i) {
         //    mat_ukn[i] *= v[i];
         //    mat_kn[i] *= v[i];
         // }
         /* ------------------------------------------------------ */
         if (this->lu)
            delete this->lu;
#if defined(use_CG)
         this->lu = new lapack_lu(mat_ukn /*Êú™Áü•„ÅÆË°åÂàó‰øÇÊï∞ÔºàÂ∑¶Ëæ∫Ôºâ*/);
         std::cout << "The conjugate gradient is used" << std::endl;
         GradientMethod gd1(mat_ukn);
         phiORphin = gd1.solve(Dot(mat_kn, knowns), {}, 1E-1);
         GradientMethod gd2(mat_ukn);
         phiORphin = gd2.solveCG(Dot(mat_kn, knowns), phiORphin);
#elif defined(use_gmres)
         std::cout << "gmres for phiORphin" << std::endl;
         gmres gm(mat_ukn /*Êú™Áü•„ÅÆË°åÂàó‰øÇÊï∞ÔºàÂ∑¶Ëæ∫Ôºâ*/, Dot(mat_kn, knowns) /*Êó¢Áü•„ÅÆ„Éô„ÇØ„Éà„É´ÔºàÂè≥Ëæ∫Ôºâ*/, phiORphin /*Ëß£*/, use_gmres);
         phiORphin = gm.x;
         std::cout << "gm.err = " << gm.err << ", isFinite(gm.err) = " << isFinite(gm.err) << std::endl;
         if (real_time < 0.005 || !isFinite(gm.err < 1E-20)) {
            std::cout << "lapack lu decomposition" << std::endl;
            this->lu = new lapack_lu(mat_ukn /*Êú™Áü•„ÅÆË°åÂàó‰øÇÊï∞ÔºàÂ∑¶Ëæ∫Ôºâ*/, Dot(mat_kn, knowns) /*Êó¢Áü•„ÅÆ„Éô„ÇØ„Éà„É´ÔºàÂè≥Ëæ∫Ôºâ*/, phiORphin /*Ëß£*/);
         }
         // auto err = Norm(Dot(mat_ukn, gm.x) - Dot(mat_kn, knowns));
         // std::cout << err << std::endl;
#elif defined(use_lapack)
         std::cout << "lapack lu decomposition" << std::endl;
         // this->lu = new lapack_lu(mat_ukn /*Êú™Áü•„ÅÆË°åÂàó‰øÇÊï∞ÔºàÂ∑¶Ëæ∫Ôºâ*/);
         // std::cout << "try to solve" << std::endl;
         // this->lu->solve(Dot(mat_kn, knowns) /*Êó¢Áü•„ÅÆ„Éô„ÇØ„Éà„É´ÔºàÂè≥Ëæ∫Ôºâ*/, phiORphin /*Ëß£*/);
         this->lu = new lapack_lu(mat_ukn /*Êú™Áü•„ÅÆË°åÂàó‰øÇÊï∞ÔºàÂ∑¶Ëæ∫Ôºâ*/, Dot(mat_kn, knowns) /*Êó¢Áü•„ÅÆ„Éô„ÇØ„Éà„É´ÔºàÂè≥Ëæ∫Ôºâ*/, phiORphin /*Ëß£*/);
#elif defined(use_lu)
         std::cout << "parallel lu decomposition" << std::endl;
         this->lu = new ludcmp_parallel(mat_ukn /*Êú™Áü•„ÅÆË°åÂàó‰øÇÊï∞ÔºàÂ∑¶Ëæ∫Ôºâ*/);
         std::cout << "try to solve" << std::endl;
         this->lu->solve(Dot(mat_kn, knowns) /*Êó¢Áü•„ÅÆ„Éô„ÇØ„Éà„É´ÔºàÂè≥Ëæ∫Ôºâ*/, phiORphin /*Ëß£*/);
#else
         //* Êú™Áü•Â§âÊï∞„ÅÆË®àÁÆó
         std::cout << "SVD decomposition" << std::endl;
         SVD svd(mat_ukn);
         svd.solve(Dot(mat_kn, knowns) /*Êó¢Áü•„ÅÆ„Éô„ÇØ„Éà„É´ÔºàÂè≥Ëæ∫Ôºâ*/, phiORphin /*Ëß£*/);
#endif
         std::cout << Blue << "Elapsed time for solving BIE: " << Red << watch() << colorOff << " s\n";
         // Ë∂≥„ÅóÂêà„Çè„Åõ„Çã„ÅÆ„ÅßÂàùÊúüÂåñ
         for (const auto &[PBF, i] : PBF_index) {
            auto [p, DorN, f] = PBF;
            if (DorN == Dirichlet) {
               // do nothing
            } else if (p->phinOnFace.size() > 1) {
               std::get<0>(p->phiphin) = 0;
               std::get<1>(p->phiphin) = 0;
            } else
               std::get<0>(p->phiphin) = 0;
         }

         for (const auto &[PBF, i] : PBF_index) {
            auto [p, DorN, f] = PBF;
            if (DorN == Dirichlet)
               std::get<1>(p->phiphin) = p->phin_Dirichlet = phiORphin[i];
            else if (p->phinOnFace.size() > 1) {
               double total = 0;
               for (auto [f, phin] : p->phinOnFace)
                  total += f->area;
               std::get<0>(p->phiphin) += phiORphin[i] * f->area / total;
               std::get<1>(p->phiphin) += p->phinOnFace.at(f) * f->area / total;
            } else {
               std::get<0>(p->phiphin) = phiORphin[i];
               std::get<1>(p->phiphin) = p->phinOnFace.at(f);
            }
         }

         if (!isFinite(phiORphin))
            throw error_message(__FILE__, __PRETTY_FUNCTION__, __LINE__, "phiORphin is not finite");
      }
   };
};

#endif