#include "fundamental.hpp"
#include "GNUPLOT.hpp"

#define case_2d_struct

#if defined(check_Bspline_basis)
// Bsplineは，K=1の場合，1 or 0となる．
// このようにK=1を最低次数として定義した場合，
// K=1 -> q.size()>2
// K=2 -> q.size()>3
// q.size()>K+1　の　ノットを与える必要がある．

// Bspline_knotは，データ点数+Kのノットを与える．
int main()
{
  V_d sample = {-1, -0.5, 0., 0.1, 0.2, 3., 4.};

  GNUPLOT plot;
  for (auto K = 6; K > 0; K--)
  {
    auto q = Bspline_knot(sample, K);
    V_d x = Subdivide(Min(sample), Max(sample), 100);

    V_d sum(x.size(), 0.);
    for (auto i = 0; i < sample.size() /*N-1まで*/; i++)
    {
      // 0からN-1までのBspline関数の線形結合で，目的の関数を表現するのだった．
      auto b_i_x = Bspline(x, q, i, K);
      sum += b_i_x;
      auto vv = Transpose(VV_d{x, b_i_x});
      plot.SaveData(vv, {{"w", "l"}});
    }

    plot.SaveData(Transpose(VV_d{x, sum}), {{"w", "l"}});

    V_d dummypoints(sample.size(), 0.);
    plot.SaveData(Transpose(VV_d{sample, dummypoints}), {{"w", "p"}});

    plot.plot2d();
    std::cin.ignore();
    plot.Clear();
  }
}

#elif defined(case_2d_parametric_old)

int main()
{
  //ソートするように
  VV_d sample = {{-10., -0.544021}, {-8.5, 0.798487}, {-7., 0.656987}, {-5.5, -0.70554}, {-4., -0.756802}, {-2.5, 0.598472}, {-1., 0.841471}, {0.5, 0.479426}, {2., 0.909297}, {3.5, -0.350783}, {5., -0.958924}, {6.5, 0.21512}, {8., 0.989358}, {9.5, -0.0751511}};
  // VV_d sample = {{-1.,-0.841471},{-0.9,-0.783327},{-0.8,-0.717356},{-0.7,-0.644218},{-0.6,-0.564642},{-0.5,-0.479426},{-0.4,-0.389418},{-0.3,-0.29552},{-0.2,-0.198669},{-0.1,-0.0998334},{0.,0.},{0.1,0.0998334},{0.2,0.198669},{0.3,0.29552},{0.4,0.389418},{0.5,0.479426},{0.6,0.564642},{0.7,0.644218},{0.8,0.717356},{0.9,0.783327},{1.,0.841471}};
  // VV_d sample = {{-1.,-0.841471},{-0.95,-0.813416},{-0.9,-0.783327},{-0.85,-0.75128},{-0.8,-0.717356},{-0.75,-0.681639},{-0.7,-0.644218},{-0.65,-0.605186},{-0.6,-0.564642},{-0.55,-0.522687},{-0.5,-0.479426},{-0.45,-0.434966},{-0.4,-0.389418},{-0.35,-0.342898},{-0.3,-0.29552},{-0.25,-0.247404},{-0.2,-0.198669},{-0.15,-0.149438},{-0.1,-0.0998334},{-0.05,-0.0499792},{0.,0.},{0.05,0.0499792},{0.1,0.0998334},{0.15,0.149438},{0.2,0.198669},{0.25,0.247404},{0.3,0.29552},{0.35,0.342898},{0.4,0.389418},{0.45,0.434966},{0.5,0.479426},{0.55,0.522687},{0.6,0.564642},{0.65,0.605186},{0.7,0.644218},{0.75,0.681639},{0.8,0.717356},{0.85,0.75128},{0.9,0.783327},{0.95,0.813416},{1.,0.841471}};
  VV_d sampleT = Transpose(sample);

  GNUPLOT plot;
  for (auto K = 5; K > 0; K--)
  {

    // auto q = OpenUniformKnots(sampleT[0].size(), K);
    // V_d a(sampleT[0].size(), 0.), b(sampleT[0].size(), 0.);

    // auto param = Subdivide(-1., 1., sampleT[0].size() - 1);

    // std::cout << "q = " << q << std::endl;
    // std::cout << "param = " << param << std::endl;

    // {
    //   VV_d A = Bspline(param, q, K); //この点の上では，サンプル値と一致しなければならない
    //   ludcmp lu(A);
    //   lu.solve(sampleT[0], a);
    // }

    // std::cout << "a = " << a << std::endl;

    // {
    //   VV_d B = Bspline(param, q, K); //この点の上では，サンプル値と一致しなければならない
    //   ludcmp lu(B);
    //   lu.solve(sampleT[1], b);
    // }

    // std::cout << "b = " << b << std::endl;

    V_d x = Subdivide(-1., 1., 10);
    // auto basis = Bspline(x, q, K);

    // std::cout << "x = " << x << std::endl;
    // std::cout << "basis = " << basis << std::endl;

    ParametricInterpolation interp(sample, K);

    V_d v;
    for (auto h : x)
      v.push_back(interp(h));

    Print(v);
    auto data = Transpose(VV_d{x, v});
    Print(data);
    plot.SaveData(data, {{"w", "l"}});

    plot.plot2d();
    std::cin.ignore();
    plot.Clear();
  }
}

#elif defined(case_2d_parametric)

int main()
{
  //ソートするように
  VV_d sample = {{-10., -0.544021}, {-8.5, 0.798487}, {-7., 0.656987}, {-5.5, -0.70554}, {-4., -0.756802}, {-2.5, 0.598472}, {-1., 0.841471}, {0.5, 0.479426}, {2., 0.909297}, {3.5, -0.350783}, {5., -0.958924}, {6.5, 0.21512}, {8., 0.989358}, {9.5, -0.0751511}};
  // VV_d sample = {{-1.,-0.841471},{-0.9,-0.783327},{-0.8,-0.717356},{-0.7,-0.644218},{-0.6,-0.564642},{-0.5,-0.479426},{-0.4,-0.389418},{-0.3,-0.29552},{-0.2,-0.198669},{-0.1,-0.0998334},{0.,0.},{0.1,0.0998334},{0.2,0.198669},{0.3,0.29552},{0.4,0.389418},{0.5,0.479426},{0.6,0.564642},{0.7,0.644218},{0.8,0.717356},{0.9,0.783327},{1.,0.841471}};
  // VV_d sample = {{-1.,-0.841471},{-0.95,-0.813416},{-0.9,-0.783327},{-0.85,-0.75128},{-0.8,-0.717356},{-0.75,-0.681639},{-0.7,-0.644218},{-0.65,-0.605186},{-0.6,-0.564642},{-0.55,-0.522687},{-0.5,-0.479426},{-0.45,-0.434966},{-0.4,-0.389418},{-0.35,-0.342898},{-0.3,-0.29552},{-0.25,-0.247404},{-0.2,-0.198669},{-0.15,-0.149438},{-0.1,-0.0998334},{-0.05,-0.0499792},{0.,0.},{0.05,0.0499792},{0.1,0.0998334},{0.15,0.149438},{0.2,0.198669},{0.25,0.247404},{0.3,0.29552},{0.35,0.342898},{0.4,0.389418},{0.45,0.434966},{0.5,0.479426},{0.55,0.522687},{0.6,0.564642},{0.65,0.605186},{0.7,0.644218},{0.75,0.681639},{0.8,0.717356},{0.85,0.75128},{0.9,0.783327},{0.95,0.813416},{1.,0.841471}};
  VV_d sampleT = Transpose(sample);

  GNUPLOT plot;
  for (auto K = 5; K > 0; K--)
  {
    auto N = sampleT[0].size();
    auto q = OpenUniformKnots(N, K);
    V_d a(N, 0.), b(N, 0.);

    auto param = Subdivide(-1., 1., N - 1);

    std::cout << "q.size() = " << q.size() << ", q = " << q << std::endl;
    std::cout << "param.size() = " << param.size() << "param = " << param << std::endl;

    auto BASIS = Bspline(param, q, K);
    std::cout << "BASIS.size() = " << BASIS.size() << "BASIS = " << BASIS << std::endl;
    {
      VV_d A = BASIS; //この点の上では，サンプル値と一致しなければならない
      ludcmp lu(A);
      lu.solve(sampleT[0], a);
    }

    std::cout << "a = " << a << std::endl;

    {
      VV_d B = Bspline(param, q, K); //この点の上では，サンプル値と一致しなければならない
      ludcmp lu(B);
      lu.solve(sampleT[1], b);
    }

    std::cout << "b = " << b << std::endl;

    V_d x = Subdivide(-1., 1., 100);
    auto basis = Bspline(x, q, K);

    std::cout << "x = " << x << std::endl;
    std::cout << "basis = " << basis << std::endl;

    // for (auto i = 0; i < b.size(); i++)
    //   plot.SaveData(Transpose(VV_d{a[i] * basis[i], b[i] * basis[i]}), {{"w", "l"}});

    plot.SaveData(Transpose(VV_d{Dot(a, basis), Dot(b, basis)}), {{"w", "l"}});

    plot.SaveData(sample, {{"w", "p"}, {"ps", "3"}});

    plot.plot2d();
    std::cin.ignore();
    plot.Clear();
  }
}
#elif defined(case_2d_struct)

struct InterpolationBspline
{
  int K;
  std::vector<Tdd> sample;
  std::tuple<V_d, V_d> sampleT;
  V_d a, q;
  InterpolationBspline(const int K_IN, const std::vector<Tdd> &sample_IN) : K(K_IN),
                                                                            sample(sample_IN),
                                                                            sampleT(Transpose(sample_IN)),
                                                                            q(OpenUniformKnots(std::get<0>(sampleT), K))
  {
    VV_d A = Bspline(std::get<0>(sampleT), q, K); //この点の上では，サンプル値と一致しなければならない．
    a.resize(A.size());
    ludcmp lu(A);
    lu.solve(std::get<1>(sampleT), a);
  };
  //! ------------------------------------------------------ */
  double operator()(const double x) const
  {
    return Dot(Bspline(x, q, K), a /*{B0,B1,B2,B3,...}*/);
  };
  //! ------------------------------------------------------ */
  V_d operator()(const V_d &X) const
  {
    V_d ret(X.size());
    for (auto i = 0; i < X.size(); ++i)
      ret[i] = Dot(Bspline(X[i], q, K), a);
    return ret;
  };
  //! ------------------------------------------------------ */
  double D(const double x) const
  {
    return Dot(D_Bspline(x, q, K), a /*{B0,B1,B2,B3,...}*/);
  };
  V_d D(const V_d &X) const
  {
    V_d ret(X.size());
    for (auto i = 0; i < X.size(); ++i)
      ret[i] = Dot(D_Bspline(X[i], q, K), a);
    return ret;
  };
};

int main()
{
  std::vector<Tdd> sample =
      {
          {-0.09594722365480488, -0.07202607278652906},
          {-0.024712050885336095, -0.07202607278652906},
          {-0.0009669932955131411, -0.07202607278652906},
          {-0., -0.07202607278652906},
          {0.009992264053635902, -0.07048705413724424},
          {0.019124978511260105, -0.06894803548795944},
          {0.028257692968884307, -0.06556219445953285},
          {0.053829293450232074, -0.056635886293680965},
          {0.06661509369090596, -0.051711026615969574},
          {0.09036015128072888, -0.03970668115154807},
          {0.11410520887055181, -0.025547709578127825},
          {0.13785026646037474, -0.012619952924135425},
          {0.16342186694172256, 0.0021546261089987473},
          {0.1871669245315455, 0.018160420061560753},
          {0.2109119821213684, 0.0347818214738367},
          {0.23465703971119134, 0.05140322288611263},
          {0.25840209730101427, 0.06833242802824553},
          {0.28032061199931235, 0.08279920333152274},
          {0.3040656695891353, 0.088647474198805},
          {0.31685146982980916, 0.08926308165851893},
          {0.32963727007048305, 0.08895527792866197},
          {0.34242307031115693, 0.08618504435994931},
          {0.3625150421179302, 0.08279920333152274},
          {0.3862600997077531, 0.08002896976281007},
          {0.41000515729757603, 0.07879775484338222},
          {0.4410563864534983, 0.07879775484338222},
          {0.5, 0.07879775484338222}

      };

  // std::vector<Tdd> sample = {
  //     {-0.15000000000000002, 0.},
  //     {-0.11, 0.},
  //     {-0.1, 0.},
  //     {-0.09, 0.},
  //     {-0.08, 0.},
  //     {-0.07, 0.},
  //     {-0.06, 0.},
  //     {-0.050409836065573754, 0.007920792079208039},
  //     {-0.02397540983606558, 0.06930693069306948},
  //     {-0.0006147540983606481, 0.13762376237623775},
  //     {0.0282786885245902, 0.24851485148514862},
  //     {0.05040983606557381, 0.3594059405940595},
  //     {0.05901639344262294, 0.40297029702970305},
  //     {0.06946721311475412, 0.4425742574257427},
  //     {0.08299180327868855, 0.4792079207920793},
  //     {0.10020491803278692, 0.516831683168317},
  //     {0.11065573770491804, 0.5415841584158416},
  //     {0.12110655737704923, 0.5663366336633664},
  //     {0.132172131147541, 0.5910891089108912},
  //     {0.15000000000000008, 0.6198019801980199},
  //     {0.1616803278688525, 0.6306930693069308},
  //     {0.17643442622950822, 0.6445544554455447},
  //     {0.18872950819672135, 0.6603960396039605},
  //     {0.20102459016393448, 0.6792079207920793},
  //     {0.21823770491803285, 0.6801980198019802},
  //     {0.23053278688524592, 0.6445544554455447},
  //     {0.25081967213114753, 0.5742574257425743},
  //     {0.27848360655737703, 0.40297029702970305},
  //     {0.30000000000000004, 0.23564356435643574},
  //     {0.319672131147541, 0.10396039603960416},
  //     {0.3319672131147542, 0.02772277227722786},
  //     {0.35040983606557385, -0.03960396039603942},
  //     {0.37069672131147546, -0.085148514851485},
  //     {0.38913934426229513, -0.08316831683168302},
  //     {0.4002049180327869, -0.06831683168316827},
  //     {0.4254098360655738, -0.03069306930693061},
  //     {0.45000000000000007, -0.009900990099009799},
  //     {0.5, 0.},
  //     {0.55, 0.},
  //     {0.6, 0.},
  //     {0.65, 0.},
  //     {0.7, 0.}};

  std::tuple<V_d, V_d> sampleT = Transpose(sample);

  GNUPLOT plot;
  V_d x = Subdivide(Min(std::get<0>(sampleT)), Max(std::get<0>(sampleT)), 300);

  auto intp = InterpolationBspline(3, sample);

  auto vv = Transpose(VV_d{x, intp.D(x)});
  plot.SaveData(vv, {{"w", "l"}, {"lc", "black"}});

  plot.plot2d();
  std::cin.ignore();
  plot.Clear();
}

#elif defined(case_2d)

struct InterpolationBspline
{
  int K;
  std::vector<Tdd> sample;
  std::tuple<V_d, V_d> sampleT;
  V_d a, q;
  InterpolationBspline(const int K_IN, const std::vector<Tdd> &sample_IN) : K(K_IN),
                                                                            sample(sample_IN),
                                                                            sampleT(Transpose(sample_IN)),
                                                                            q(OpenUniformKnots(std::get<0>(sampleT), K))
  {
    VV_d A = Bspline(std::get<0>(sampleT), q, K); //この点の上では，サンプル値と一致しなければならない．
    a.resize(A.size());
    ludcmp lu(A);
    lu.solve(std::get<1>(sampleT), a);
  };
  //! ------------------------------------------------------ */
  double operator()(const double x) const
  {
    return Dot(Bspline(x, q, K), a /*{B0,B1,B2,B3,...}*/);
  };
  //! ------------------------------------------------------ */
  // double D(const double x) const
  // {
  //   return Dot(D_Bspline(x, q, K), a /*{B0,B1,B2,B3,...}*/);
  // };
};

int main()
{

  VV_d sample = {
      {-0.1466367713004484, 0.},
      {-0.12376681614349773, 0.},
      {-0.09955156950672643, 0.},
      {-0.07802690582959637, 0.},
      {-0.05919282511210758, 0.0021660649819494893},
      {-0.052466367713004475, 0.006498194945848357},
      {-0.03766816143497756, 0.034657039711191384},
      {-0.021524663677130046, 0.07581227436823101},
      {-0.008071748878923729, 0.12129963898916973},
      {0.006726457399103131, 0.16895306859205772},
      {0.018834080717488794, 0.21444043321299633},
      {0.02959641255605383, 0.2642599277978339},
      {0.04035874439461884, 0.3097472924187725},
      {0.04977578475336325, 0.3595667870036101},
      {0.06053811659192826, 0.40938628158844764},
      {0.06860986547085202, 0.444043321299639},
      {0.08206278026905828, 0.47870036101083036},
      {0.09686098654708525, 0.5155234657039711},
      {0.11434977578475336, 0.552346570397112},
      {0.13049327354260087, 0.5913357400722021},
      {0.1493273542600897, 0.6194945848375452},
      {0.16816143497757846, 0.6389891696750902},
      {0.18430493273542603, 0.6606498194945849},
      {0.19910313901345295, 0.6758122743682311},
      {0.20448430493273545, 0.6931407942238268},
      {0.20986547085201795, 0.6823104693140795},
      {0.21928251121076225, 0.6823104693140795},
      {0.22466367713004481, 0.6671480144404333},
      {0.22869955156950666, 0.6498194945848376},
      {0.23677130044843048, 0.6303249097472924},
      {0.24349775784753364, 0.604332129963899},
      {0.25022421524663674, 0.5740072202166064},
      {0.2569506726457399, 0.5371841155234658},
      {0.26502242152466365, 0.4916967509025271},
      {0.27443946188340806, 0.43104693140794226},
      {0.28251121076233177, 0.3747292418772563},
      {0.2905829596412556, 0.31841155234657037},
      {0.29730941704035874, 0.2620938628158844},
      {0.30269058295964124, 0.21227436823104695},
      {0.31076233183856494, 0.16678700361010823},
      {0.31614349775784756, 0.11913357400722024},
      {0.3228699551569506, 0.06281588447653419},
      {0.33497757847533627, 0.012996389891696714},
      {0.3457399103139013, -0.028158844765343027},
      {0.36053811659192825, -0.06498194945848368},
      {0.37399103139013445, -0.08447653429602886},
      {0.3887892376681614, -0.08014440433212999},
      {0.40762331838565025, -0.05631768953068583},
      {0.42107623318385645, -0.030324909747292517},
      {0.4399103139013453, -0.015162454873646203},
      {0.4614349775784753, 0},
      {0.4856502242152465, 0},
      {0.5085201793721973, 0},
      {0.5327354260089686, 0.},
      {0.5556053811659193, 0.},
      {0.5784753363228698, 0.},
      {0.6013452914798205, 0.},
      {0.6255605381165918, 0.},
      {0.6484304932735424, 0.},
      {0.6699551569506725, 0.},
      {0.6928251121076233, 0.}};

  //ソートするように
  // VV_d sample = {{-10., -0.544021},
  //                {-8.5, 0.798487},
  //                {-7., 0.656987},
  //                {-5.5, -0.70554},
  //                {-4., -0.756802},
  //                {-2.5, 0.598472},
  //                {-1., 0.841471},
  //                {0.5, 0.479426},
  //                {2., 0.909297},
  //                {3.5, -0.350783},
  //                {5., -0.958924},
  //                {6.5, 0.21512},
  //                {8., 0.989358},
  //                {9.5, -0.0751511}};
  // VV_d sample = {{-1.,-0.841471},{-0.9,-0.783327},{-0.8,-0.717356},{-0.7,-0.644218},{-0.6,-0.564642},{-0.5,-0.479426},{-0.4,-0.389418},{-0.3,-0.29552},{-0.2,-0.198669},{-0.1,-0.0998334},{0.,0.},{0.1,0.0998334},{0.2,0.198669},{0.3,0.29552},{0.4,0.389418},{0.5,0.479426},{0.6,0.564642},{0.7,0.644218},{0.8,0.717356},{0.9,0.783327},{1.,0.841471}};
  // VV_d sample = {{-1.,-0.841471},{-0.95,-0.813416},{-0.9,-0.783327},{-0.85,-0.75128},{-0.8,-0.717356},{-0.75,-0.681639},{-0.7,-0.644218},{-0.65,-0.605186},{-0.6,-0.564642},{-0.55,-0.522687},{-0.5,-0.479426},{-0.45,-0.434966},{-0.4,-0.389418},{-0.35,-0.342898},{-0.3,-0.29552},{-0.25,-0.247404},{-0.2,-0.198669},{-0.15,-0.149438},{-0.1,-0.0998334},{-0.05,-0.0499792},{0.,0.},{0.05,0.0499792},{0.1,0.0998334},{0.15,0.149438},{0.2,0.198669},{0.25,0.247404},{0.3,0.29552},{0.35,0.342898},{0.4,0.389418},{0.45,0.434966},{0.5,0.479426},{0.55,0.522687},{0.6,0.564642},{0.65,0.605186},{0.7,0.644218},{0.75,0.681639},{0.8,0.717356},{0.85,0.75128},{0.9,0.783327},{0.95,0.813416},{1.,0.841471}};
  VV_d sampleT = Transpose(sample);

  GNUPLOT plot;
  for (auto K = 5; K > 0; K--)
  {
    Print(sampleT[0]);
    auto q = OpenUniformKnots(sampleT[0], K);

    std::cout << "q = " << q << std::endl;

    VV_d A = Bspline(sampleT[0], q, K); //この点の上では，サンプル値と一致しなければならない．
    std::cout << "A = " << A << std::endl;

    std::cout << "   A.size() = " << A.size() << std::endl;
    std::cout << "A[0].size() = " << A[0].size() << std::endl;
    // A.a = sampleT[1]が満たすべき方程式

    V_d a(A.size(), 0.);
    ludcmp lu(A);
    lu.solve(sampleT[1], a);

    std::cout << "a = " << a << std::endl;

    V_d x = Subdivide(Min(sampleT[0]), Max(sampleT[0]), 300);

    // 0からN-1までのBspline関数の線形結合で，目的の関数を表現するのだった．

    // Bspline(x, q, K)[0]はB_0(x)に対応する
    // Bspline(x, q, K)[0] = {B_0(x),B_1(x),B_2(x),B_3(x),....}となっている
    //  auto b = Bspline(x, q, K);
    for (auto i = 0; i < q.size() - K; i++)
    {
      std::cout << "x.size() =" << x.size() << ", x = " << x << std::endl;
      // std::cout << "b_i.size() =" << a[i] * Transpose(b)[i].size() << ", a[i]*b[i] = " << a[i] * Transpose(b)[i] << std::endl;
      auto vv = Transpose(VV_d{x, a[i] * Bspline(x, q, i, K)});
      // plot.SaveData(vv, {{"w", "l"}});
    }

    auto vv = Transpose(VV_d{x, Dot(Bspline(x, q, K), a /*{B0,B1,B2,B3,...}*/)});
    plot.SaveData(vv, {{"w", "l"}});

    // V_d dummypoints(q.size(), 0.5);
    // plot.SaveData(Transpose(VV_d{q, dummypoints}), {{"w", "p"}});

    // plot.SaveData(sample, {{"w", "p"}, {"ps", "3"}});

    plot.plot2d();
    std::cin.ignore();
    plot.Clear();
  }
}

#elif defined(case_3d_mod)

int main()
{

  //ソートするように
  // VV_d sample = {{1.4619,6.70796,0.549888},{3.82738,3.56637,-0.868296},{-0.903572,5.13717,-0.875833},{-3.26905,-7.4292,0.965705},{-3.26905,3.56637,-0.992129},{6.19286,6.70796,0.290981},{-5.63452,-1.14602,-0.508375},{6.19286,3.56637,0.75991},{8.55833,6.70796,-0.992607},{-8.,-7.4292,-0.996958},{-8.,5.13717,-0.0825191},{-8.,-5.85841,-0.471432},{-8.,3.56637,0.61772},{8.55833,-9.,-0.146301},{-3.26905,0.424778,-0.154318},{8.55833,5.13717,-0.528627},{-5.63452,-9.,-0.929665},{-8.,-5.85841,-0.471432},{1.4619,5.13717,-0.80877},{1.4619,6.70796,0.549888},{8.55833,6.70796,-0.992607},{3.82738,-4.28761,-0.510528},{3.82738,5.13717,0.122699},{-8.,5.13717,-0.0825191},{-8.,3.56637,0.61772},{-8.,-9.,-0.501019},{6.19286,-7.4292,-0.244558},{1.4619,6.70796,0.549888},{8.55833,-2.71681,0.430975},{-3.26905,-5.85841,0.412855},{-0.903572,3.56637,-0.511957},{3.82738,5.13717,0.122699},{-8.,-5.85841,-0.471432},{1.4619,-7.4292,0.960415},{6.19286,-5.85841,0.783306},{1.4619,-9.,0.302028},{-0.903572,-2.71681,0.274876},{3.82738,-9.,-0.34782},{-8.,-9.,-0.501019},{-0.903572,-7.4292,0.932316},{-3.26905,0.424778,-0.154318},{-8.,-2.71681,0.828288},{3.82738,3.56637,-0.868296},{-0.903572,-5.85841,-0.348065},{-8.,3.56637,0.61772},{3.82738,1.99557,-0.922609},{6.19286,5.13717,0.981576},{-8.,-5.85841,-0.471432},{-8.,0.424778,0.987656},{1.4619,9.84956,-0.507842},{-5.63452,6.70796,0.616568},{8.55833,0.424778,0.755168}};

  VV_d sample = {{1.5, 1., 0.73846},
                 {-1.5, 1.33333, -0.778662},
                 {-1., 1., -0.350175},
                 {1.5, 2., 0.797984},
                 {0., 1., 0.454649},
                 {0., -2., -0.491295},
                 {2., -2., -0.491295},
                 {-1., -0.666667, 0.257333},
                 {2., -2., -0.491295},
                 {1.5, -0.333333, -0.28714},
                 {1., -1.33333, -0.971938},
                 {-0.5, -1.33333, -0.0687522},
                 {-2., 0., 0.},
                 {1., -1.33333, -0.971938},
                 {-2., -2., 0.900198},
                 {0., -0.666667, -0.334107},
                 {-0.5, -1.66667, -0.0704124},
                 {-1., -0.666667, 0.257333},
                 {-2., -1.66667, 0.985446},
                 {-0.5, 2., 0.0643212},
                 {0., 1.66667, 0.537821},
                 {-1.5, 0.666667, -0.495403},
                 {-1.5, 1., -0.674139},
                 {-2., 0.333333, -0.32392},
                 {0., -0.666667, -0.334107},
                 {-2., -1.66667, 0.985446},
                 {1., -1.66667, -0.995408},
                 {-1.5, 0., 0.},
                 {0.5, 0.333333, 0.28714},
                 {1.5, -0.333333, -0.28714},
                 {2., 2., 0.491295},
                 {1., 2., 0.909297},
                 {0., 2., 0.491295},
                 {1.5, -1.66667, -0.873553},
                 {0.5, 1., 0.73846},
                 {-0.5, -0.666667, -0.0437417},
                 {-1.5, -1., 0.674139},
                 {0., 1.66667, 0.537821},
                 {-2., -1., 0.83305},
                 {0., -0.333333, -0.176784},
                 {1.5, 0.333333, 0.28714},
                 {1., -1., -0.841471},
                 {0.5, 0.333333, 0.28714},
                 {-0.5, 0.666667, 0.0437417},
                 {1.5, -1.66667, -0.873553},
                 {2., -2., -0.491295},
                 {1., 0.666667, 0.61837},
                 {0.5, 1., 0.73846},
                 {2., 0.666667, 0.334107},
                 {1., -2., -0.909297},
                 {-0.5, -1.33333, -0.0687522},
                 {-1.5, 2., -0.728478},
                 {2., 2., 0.491295},
                 {1., -1.66667, -0.995408},
                 {2., -0.333333, -0.176784},
                 {-1.5, -1.66667, 0.797465},
                 {-0.5, -1., -0.0595233},
                 {-1., -0.333333, 0.136161}};

  for (auto &s : sample)
  {
    s[0] += RandomReal({0., 1E-1});
    s[1] += RandomReal({0., 1E-1});
  };

  //データの中心を求める．
  V_d center = {0., 0., 0.};
  for (auto &s : sample)
  {
    center[0] += s[0];
    center[1] += s[1];
  };
  center = center / ((double)(sample.size()));
  std::cout << "データの中心" << center << std::endl;

  V_d dir0 = {0., 1., 0.};
  V_d normal = {0., 0., 1.};
  //データをそーと
  std::vector<std::vector<int>> index_ij(sample.size(), std::vector<int>(2, -1));
  for (auto i = 0; i < sample.size(); i++)
  {
    V_d XY = V_d{sample[i][0], sample[i][1]} - center;
    int count_x = 0, count_y = 0;
    for (auto j = 0; j < sample.size(); j++)
    {
      if (i != j)
      {
        V_d xy = V_d{sample[j][0], sample[j][1]} - center;
        if (Norm(xy) < Norm(XY)) //自分よりも小さいものがあれば順番を繰り上げる
          count_x++;
        if (MyVectorAngle(dir0, xy, normal) < MyVectorAngle(dir0, XY, normal))
          count_y++;
      }
    };
    index_ij[i] = {count_x, count_y};
  }

  V_d sample_sort_x(sample.size());
  V_d sample_sort_y(sample.size());

  Print(sample);
  for (auto k = 0; k < sample.size(); k++)
  {
    V_d xy = V_d{sample[k][0], sample[k][1], 0.} - center;
    sample_sort_x[index_ij[k][0]] = Norm(xy) /*sample iのx*/;
    sample_sort_y[index_ij[k][1]] = MyVectorAngle(dir0, xy, normal) /*sample jのy*/;
  };

  Print(index_ij);

  // std::sort(sample.begin(), sample.end(), [](const V_d &v, const V_d &w) { return Norm(V_d{v[0], v[1]}) < Norm(V_d{w[0], w[1]}); });

  VV_d sampleT = Transpose(sample);
  V_d X = sampleT[0];
  V_d Y = sampleT[1];
  V_d Z = sampleT[2];

  GNUPLOT plot;
  for (auto K = 5; K > 1; K--)
  {

    // V_d R;
    // for (auto i = 0; i < sample.size(); i++)
    //   R.push_back(Norm(V_d{sample[i][0], sample[i][1]}));

    auto q4x = OpenUniformKnots(sample_sort_x, K);
    auto q4y = OpenUniformKnots(sample_sort_y, K);

    std::cout << Red << "sample_sort_x = " << sample_sort_x << reset << std::endl;
    std::cout << Blue << "sample_sort_y = " << sample_sort_y << reset << std::endl;
    std::cout << "q4x = " << q4x << std::endl;
    std::cout << "q4y = " << q4y << std::endl;

    V_d R({}), Theta({});
    for (auto i = 0; i < sample.size(); i++)
    {
      V_d xy = V_d{sample[i][0], sample[i][1], 0.} - center;
      auto r = Norm(xy) /*sample iのx*/;
      auto theta = MyVectorAngle(dir0, xy, normal) /*sample jのy*/;
      R.push_back(r);
      Theta.push_back(theta);
    };

    VV_d B_R = Bspline(R, q4x, K);
    VV_d B_Theta = Bspline(Theta, q4y, K);

    V_d s({});
    for (auto i = 0; i < sample.size(); i++)
      s.push_back(sample[i][2]);

    // V_d a = Dot(Dot(Inverse(Transpose(B_R)),s),Inverse(B_Theta));
    V_d a = Dot(s, Inverse(B_Theta));
    std::cout << "a = " << a << std::endl;

    V_d r = Subdivide(Min(sample_sort_x), Max(sample_sort_x), 50);
    V_d theta = Subdivide(Min(sample_sort_y), Max(sample_sort_y), 50);

    VVV_d mat;
    for (auto i = 0; i < r.size(); i++)
    {
      VV_d data;
      for (auto j = 0; j < theta.size(); j++)
      {
        double tmp = 0;
        // for (auto k = 0; k < a.size(); k++)
        //   for (auto b:Bspline(r[i], q4x, K))
        //     tmp += a[k]*b*Bspline(theta[j], q4y, K)[k];

        tmp = Dot(a, Bspline(theta[j], q4y, K));

        // Print(tmp);
        data.push_back(V_d{r[i] * cos(theta[j]), r[i] * sin(theta[j]), tmp});
      }
      mat.emplace_back(data);
    }

    plot.SaveSplotData(mat, {{"w", "l"}});
    plot.SaveSplotData({sample}, {{"w", "p"}});

    // V_d dummypoints(q.size(), 0.5);
    // plot.SaveData(Transpose(VV_d{q, dummypoints}), {{"w", "p"}});

    // plot.SaveData(sample, {{"w", "p"}, {"ps", "3"}});

    plot.plot3d();
    std::cin.ignore();
    plot.Clear();
  }
}

#elif defined(case_3d)

int main()
{

  //ソートするように
  // VV_d sample = {{1.4619,6.70796,0.549888},{3.82738,3.56637,-0.868296},{-0.903572,5.13717,-0.875833},{-3.26905,-7.4292,0.965705},{-3.26905,3.56637,-0.992129},{6.19286,6.70796,0.290981},{-5.63452,-1.14602,-0.508375},{6.19286,3.56637,0.75991},{8.55833,6.70796,-0.992607},{-8.,-7.4292,-0.996958},{-8.,5.13717,-0.0825191},{-8.,-5.85841,-0.471432},{-8.,3.56637,0.61772},{8.55833,-9.,-0.146301},{-3.26905,0.424778,-0.154318},{8.55833,5.13717,-0.528627},{-5.63452,-9.,-0.929665},{-8.,-5.85841,-0.471432},{1.4619,5.13717,-0.80877},{1.4619,6.70796,0.549888},{8.55833,6.70796,-0.992607},{3.82738,-4.28761,-0.510528},{3.82738,5.13717,0.122699},{-8.,5.13717,-0.0825191},{-8.,3.56637,0.61772},{-8.,-9.,-0.501019},{6.19286,-7.4292,-0.244558},{1.4619,6.70796,0.549888},{8.55833,-2.71681,0.430975},{-3.26905,-5.85841,0.412855},{-0.903572,3.56637,-0.511957},{3.82738,5.13717,0.122699},{-8.,-5.85841,-0.471432},{1.4619,-7.4292,0.960415},{6.19286,-5.85841,0.783306},{1.4619,-9.,0.302028},{-0.903572,-2.71681,0.274876},{3.82738,-9.,-0.34782},{-8.,-9.,-0.501019},{-0.903572,-7.4292,0.932316},{-3.26905,0.424778,-0.154318},{-8.,-2.71681,0.828288},{3.82738,3.56637,-0.868296},{-0.903572,-5.85841,-0.348065},{-8.,3.56637,0.61772},{3.82738,1.99557,-0.922609},{6.19286,5.13717,0.981576},{-8.,-5.85841,-0.471432},{-8.,0.424778,0.987656},{1.4619,9.84956,-0.507842},{-5.63452,6.70796,0.616568},{8.55833,0.424778,0.755168}};

  VV_d sample = {{1.5, 1., 0.73846},
                 {-1.5, 1.33333, -0.778662},
                 {-1., 1., -0.350175},
                 {1.5, 2., 0.797984},
                 {0., 1., 0.454649},
                 {0., -2., -0.491295},
                 {2., -2., -0.491295},
                 {-1., -0.666667, 0.257333},
                 {2., -2., -0.491295},
                 {1.5, -0.333333, -0.28714},
                 {1., -1.33333, -0.971938},
                 {-0.5, -1.33333, -0.0687522},
                 {-2., 0., 0.},
                 {1., -1.33333, -0.971938},
                 {-2., -2., 0.900198},
                 {0., -0.666667, -0.334107},
                 {-0.5, -1.66667, -0.0704124},
                 {-1., -0.666667, 0.257333},
                 {-2., -1.66667, 0.985446},
                 {-0.5, 2., 0.0643212},
                 {0., 1.66667, 0.537821},
                 {-1.5, 0.666667, -0.495403},
                 {-1.5, 1., -0.674139},
                 {-2., 0.333333, -0.32392},
                 {0., -0.666667, -0.334107},
                 {-2., -1.66667, 0.985446},
                 {1., -1.66667, -0.995408},
                 {-1.5, 0., 0.},
                 {0.5, 0.333333, 0.28714},
                 {1.5, -0.333333, -0.28714},
                 {2., 2., 0.491295},
                 {1., 2., 0.909297},
                 {0., 2., 0.491295},
                 {1.5, -1.66667, -0.873553},
                 {0.5, 1., 0.73846},
                 {-0.5, -0.666667, -0.0437417},
                 {-1.5, -1., 0.674139},
                 {0., 1.66667, 0.537821},
                 {-2., -1., 0.83305},
                 {0., -0.333333, -0.176784},
                 {1.5, 0.333333, 0.28714},
                 {1., -1., -0.841471},
                 {0.5, 0.333333, 0.28714},
                 {-0.5, 0.666667, 0.0437417},
                 {1.5, -1.66667, -0.873553},
                 {2., -2., -0.491295},
                 {1., 0.666667, 0.61837},
                 {0.5, 1., 0.73846},
                 {2., 0.666667, 0.334107},
                 {1., -2., -0.909297},
                 {-0.5, -1.33333, -0.0687522},
                 {-1.5, 2., -0.728478},
                 {2., 2., 0.491295},
                 {1., -1.66667, -0.995408},
                 {2., -0.333333, -0.176784},
                 {-1.5, -1.66667, 0.797465},
                 {-0.5, -1., -0.0595233},
                 {-1., -0.333333, 0.136161}};

  for (auto &s : sample)
  {
    s[0] += RandomReal({0., 1E-10});
    s[1] += RandomReal({0., 1E-10});
  };

  std::sort(sample.begin(), sample.end(), [](const V_d &v, const V_d &w)
            { return Norm(V_d{v[0], v[1]}) < Norm(V_d{w[0], w[1]}); });

  VV_d sampleT = Transpose(sample);
  V_d X = sampleT[0];
  V_d Y = sampleT[1];
  V_d Z = sampleT[2];

  GNUPLOT plot;
  for (auto K = 5; K > 0; K--)
  {

    V_d R;
    for (auto i = 0; i < sample.size(); i++)
      R.push_back(Norm(V_d{sample[i][0], sample[i][1]}));

    auto q = OpenUniformKnots(R, K);

    std::cout << "q = " << q << std::endl;
    std::cout << "R = " << R << std::endl;

    VV_d A;
    for (auto i = 0; i < R.size(); i++)
      A.push_back(Bspline(R[i], q, K));

    std::cout << "A = " << A << std::endl;
    std::cout << "   A.size() = " << A.size() << std::endl;
    std::cout << "A[0].size() = " << A[0].size() << std::endl;
    // A.a = sampleT[1]が満たすべき方程式

    V_d a(A.size(), 0.);
    ludcmp lu(A);
    lu.solve(Z, a);

    std::cout << "a = " << a << std::endl;

    V_d xx = Subdivide(Min(sampleT[0]), Max(sampleT[0]), 20);

    // 0からN-1までのBspline関数の線形結合で，目的の関数を表現するのだった．

    // Bspline(x, q, K)[0]はB_0(x)に対応する
    // Bspline(x, q, K)[0] = {B_0(x),B_1(x),B_2(x),B_3(x),....}となっている
    //  auto b = Bspline(x, q, K);

    // for (auto i = 0; i < q.size() - K; i++)
    // {
    //   std::cout << "x.size() =" << x.size() << ", x = " << x << std::endl;
    //   auto vv = Transpose(VV_d{x, a[i] * Bspline(x, q, i, K)});
    //   plot.SaveData(vv, {{"w", "l"}});
    // }

    VVV_d mat;
    for (auto i = 0; i < xx.size(); i++)
    {
      VV_d data;
      for (auto j = 0; j < xx.size(); j++)
      {
        auto r = Norm(V_d{xx[i], xx[j]});
        auto z = Dot(a, Bspline(r, q, K));
        data.push_back(V_d{xx[i], xx[j], z});
      }
      mat.emplace_back(data);
    }

    plot.SaveSplotData(mat, {{"w", "l"}});
    plot.SaveSplotData({sample}, {{"w", "p"}});

    // V_d dummypoints(q.size(), 0.5);
    // plot.SaveData(Transpose(VV_d{q, dummypoints}), {{"w", "p"}});

    // plot.SaveData(sample, {{"w", "p"}, {"ps", "3"}});

    plot.plot3d();
    std::cin.ignore();
    plot.Clear();
  }
}

#endif